<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Life Garden | ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ è‚²æˆãƒ‘ã‚ºãƒ«</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Life Gardenã¯ã€ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ãŸã‚·ãƒ³ãƒ—ãƒ«ã§å¥¥æ·±ã„è‚²æˆãƒ‘ã‚ºãƒ«ã€‚ç¨®ã‚’ã¾ãã€ä¸–ä»£ã‚’é€²ã‚ã€ã‚¹ã‚³ã‚¢ã¨ç¾ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ç«¶ã†ãƒ–ãƒ©ã‚¦ã‚¶ã‚²ãƒ¼ãƒ ã§ã™ã€‚">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=Zen+Kaku+Gothic+New:wght@400;700&display=swap" rel="stylesheet">

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6799951658165737" crossorigin="anonymous"></script>

  <style>
    :root {
      --bg-color: #0a0a0f;
      --primary-color: #b249f8;
      --secondary-color: #49f8f8;
      --text-color: #f0f0f5;
      --glass-bg: rgba(20, 20, 30, 0.7);
      --glass-border: rgba(255, 255, 255, 0.08);
      --section-bg: rgba(30, 30, 40, 0.5);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Zen Kaku Gothic New', 'Outfit', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      width: 100%;
      height: 100%;
      overflow-x: hidden;
    }

    body {
      overflow-y: auto;
    }

    body.game-mode {
      overflow: hidden;
    }

    #game-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      touch-action: none;
      background: #05050a;
    }

    #content-layer {
      position: relative;
      z-index: 10;
      width: 100%;
      min-height: 100vh;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .hidden {
      opacity: 0 !important;
      pointer-events: none !important;
      display: none !important;
    }

    .topbar {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.5rem;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 15;
      background: linear-gradient(180deg, rgba(10, 10, 15, 0.9), rgba(10, 10, 15, 0));
      pointer-events: none;
    }

    body.game-mode .topbar {
      display: none;
    }

    .logo {
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--secondary-color);
      text-shadow: 0 0 16px rgba(73, 248, 248, 0.4);
      pointer-events: auto;
    }

    .lang-switch {
      display: flex;
      gap: 0.35rem;
      pointer-events: auto;
    }

    .lang-btn {
      border: 1px solid var(--glass-border);
      background: rgba(255, 255, 255, 0.08);
      color: #fff;
      border-radius: 14px;
      padding: 0.45rem 0.75rem;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.15s ease;
    }

    .lang-btn.active {
      background: linear-gradient(135deg, var(--primary-color), #7c24cc);
      box-shadow: 0 0 12px rgba(178, 73, 248, 0.5);
    }

    .hero-section {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 3rem 1.5rem 2rem;
    }

    .hero-card {
      background: var(--glass-bg);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      padding: 3rem 2.6rem;
      border-radius: 24px;
      border: 1px solid var(--glass-border);
      max-width: 840px;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
    }

    .eyebrow {
      letter-spacing: 0.18em;
      font-size: 0.8rem;
      opacity: 0.7;
      margin-bottom: 0.6rem;
    }

    h1 {
      font-family: 'Outfit', sans-serif;
      font-size: 3.4rem;
      margin: 0 0 1rem;
      background: linear-gradient(135deg, #fff 30%, var(--primary-color) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(178, 73, 248, 0.4);
    }

    .subtitle {
      font-size: 1.2rem;
      line-height: 1.8;
      margin-bottom: 2.2rem;
      opacity: 0.9;
    }

    .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      justify-content: center;
      align-items: center;
    }

    .btn-start {
      background: linear-gradient(135deg, var(--primary-color), #7c24cc);
      color: #fff;
      border: none;
      padding: 1.1rem 3.6rem;
      font-size: 1.35rem;
      font-weight: 700;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(178, 73, 248, 0.4);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
      font-family: 'Outfit', sans-serif;
      letter-spacing: 0.04em;
    }

    .btn-start:hover {
      transform: scale(1.04);
      box-shadow: 0 0 30px rgba(178, 73, 248, 0.6);
    }

    .btn-ghost {
      background: rgba(255, 255, 255, 0.08);
      color: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.14);
      padding: 0.9rem 1.6rem;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.2s ease;
    }

    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .scroll-hint {
      margin-top: 1.6rem;
      opacity: 0.65;
      font-size: 0.9rem;
      letter-spacing: 0.08em;
    }

    .privacy-container {
      margin-top: 1rem;
    }

    .btn-privacy {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 0.45rem 1.4rem;
      border-radius: 16px;
      text-decoration: none;
      font-size: 0.9rem;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .btn-privacy:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
      border-color: rgba(255, 255, 255, 0.35);
    }

    .container {
      max-width: 940px;
      margin: 0 auto;
      padding: 3rem 1.4rem 5rem;
    }

    section {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 2.3rem;
      margin-bottom: 2.8rem;
      border: 1px solid var(--glass-border);
    }

    h2 {
      font-size: 1.9rem;
      margin-top: 0;
      border-left: 4px solid var(--primary-color);
      padding-left: 1rem;
      color: var(--secondary-color);
    }

    h3 {
      font-size: 1.3rem;
      margin-top: 1.8rem;
      color: #fff;
    }

    p, li {
      line-height: 1.8;
      opacity: 0.92;
      font-size: 1rem;
    }

    .note {
      background: rgba(178, 73, 248, 0.14);
      border-left: 3px solid var(--primary-color);
      padding: 1rem;
      border-radius: 8px;
      margin: 1.4rem 0;
      font-size: 0.98rem;
    }

    #game-interface {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 20;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    #hud {
      padding: 18px 20px;
      display: flex;
      justify-content: space-between;
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0.78), transparent);
    }

    .score-display {
      text-align: left;
      pointer-events: auto;
    }

    .score-val {
      font-size: 2rem;
      font-weight: 800;
      font-family: 'Outfit', sans-serif;
    }

    .score-label {
      font-size: 0.82rem;
      opacity: 0.72;
      letter-spacing: 0.1em;
    }

    #dex-pill {
      text-align: right;
      min-width: 110px;
    }

    #controls {
      padding: 32px 16px;
      display: flex;
      justify-content: center;
      gap: 14px;
      pointer-events: auto;
    }

    .ctrl-btn {
      width: 62px;
      height: 62px;
      border-radius: 50%;
      background: rgba(30, 30, 40, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 1.4rem;
      cursor: pointer;
      backdrop-filter: blur(6px);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.16s ease;
    }

    .ctrl-btn:hover {
      background: var(--primary-color);
      transform: translateY(-2px);
    }

    .ctrl-btn.active {
      background: var(--primary-color);
      box-shadow: 0 0 16px var(--primary-color);
    }

    #result-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 20, 0.92);
      backdrop-filter: blur(10px);
      z-index: 50;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      padding: 1rem;
    }

    #result-screen.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .result-content {
      background: var(--glass-bg);
      padding: 2.6rem;
      border-radius: 18px;
      border: 1px solid var(--glass-border);
      text-align: center;
      width: 90%;
      max-width: 520px;
      box-shadow: 0 0 50px rgba(178, 73, 248, 0.2);
    }

    .result-meta {
      margin-bottom: 1.8rem;
      opacity: 0.82;
      line-height: 1.6;
    }

    #toast {
      position: fixed;
      top: 18px;
      right: 18px;
      z-index: 60;
      background: rgba(20, 20, 30, 0.9);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 0.9rem 1.2rem;
      color: #fff;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.25s ease, transform 0.25s ease;
      pointer-events: none;
    }

    #toast.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .share-pulse {
      animation: pulse 1.4s ease-in-out infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0px rgba(29, 155, 240, 0.6); transform: scale(1); }
      50% { box-shadow: 0 0 26px rgba(29, 155, 240, 0.7); transform: scale(1.03); }
      100% { box-shadow: 0 0 0px rgba(29, 155, 240, 0.6); transform: scale(1); }
    }

    footer {
      text-align: center;
      padding: 1.8rem;
      font-size: 0.85rem;
      opacity: 0.65;
      background: #000;
    }

    footer a {
      color: var(--secondary-color);
      text-decoration: none;
    }

    @media (max-width: 700px) {
      h1 {
        font-size: 2.4rem;
      }
      .hero-card {
        padding: 2.3rem 1.6rem;
      }
      section {
        padding: 1.6rem;
      }
      .ctrl-btn {
        width: 56px;
        height: 56px;
        font-size: 1.2rem;
      }
      .topbar {
        padding: 0.9rem 1rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div class="topbar">
    <div class="logo">Life Garden</div>
    <div class="lang-switch">
      <button class="lang-btn active" data-lang="ja" aria-label="Switch to Japanese">JP</button>
      <button class="lang-btn" data-lang="en" aria-label="Switch to English">EN</button>
    </div>
  </div>

  <div id="content-layer">
    <div class="hero-section">
      <div class="hero-card">
        <div class="eyebrow" data-i18n="concept">Eternal Simple Fun</div>
        <h1 data-i18n="title">Life Garden</h1>
        <p class="subtitle" data-i18n="subtitle">
          ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã®å¢—æ®–ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã€Œè‚²ã¦ã¦ã€ã‚¹ã‚³ã‚¢ã‚’ç«¶ãEã‚·ãƒ³ãƒ—ãƒ«ã§å¥¥æ·±ãEçœºã‚ã¦è‰¯ã—Eè§¦ã£ã¦è‰¯ã—Eãƒã‚ªãƒ³è‚²æˆãƒ‘ã‚ºãƒ«ã€E        </p>
        <div class="cta-row">
          <button id="hero-start-btn" class="btn-start" data-i18n="btnStart">GAME START</button>
          <a href="privacy.html" class="btn-privacy">Privacy Policy</a>
        </div>
        <p class="scroll-hint" data-i18n="scrollHint">â†ESCROLL FOR INFO</p>
      </div>
    </div>

    <div class="container">
      <section id="about">
        <h2 data-i18n="aboutTitle">Life Garden ã¨ã¯</h2>
        <p data-i18n="aboutBody">
          Life Garden ã¯ã€ã‚³ãƒ³ã‚¦ã‚§ã‚¤ã®ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã‚’åœŸå°ã«ã—ã¤ã¤ã€ã€Œã‚¹ã‚³ã‚¢ã€ã€Œãƒ«ãƒ¼ãƒ—æ¤œçŸ¥ã€ã€Œãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®‰å®šæ€§ã€ã‚’ã‚²ãƒ¼ãƒ ã¨ã—ã¦æ¥½ã—ã‚ã‚‹ã‚ˆãEæ•´ã—ãŸãƒ–ãƒ©ã‚¦ã‚¶ã‚²ãƒ¼ãƒ ã§ã™ã€E        </p>
        <div class="note" data-i18n-html="noteBody">
          ç”Ÿãã¦ãEã‚»ãƒ«ã¯ 2ã€E å€‹Eéš£æ¥ã§ç”Ÿå­˜ã€E å€‹ã§èª•ç”Ÿã€‚ãã‚Œä»¥å¤–Eæ·˜æ±°ã•ã‚Œã‚‹ã€‚ãŸã£ãŸã“ã‚Œã ã‘Eãƒ«ãƒ¼ãƒ«ã‹ã‚‰ã€ä¿¡ã˜ã‚‰ã‚ŒãªãEã©å¤šå½©ãªè»Œè·¡ãŒç”Ÿã¾ã‚Œã¾ã™ã€E        </div>
      </section>

      <section id="howto">
        <h2 data-i18n="howtoTitle">éŠEæ–¹ã¨æˆ¦ç•¥</h2>
        <h3 data-i18n="howtoPlantTitle">1. ç¨®ã‚’ã¾ãE(Plant)</h3>
        <p data-i18n="howtoPlantBody">
          ç›¤é¢ã‚’æŒ‡ã‚EEã‚¦ã‚¹ã§ãƒ‰ãƒ©ãƒEã—ã¦ã‚»ãƒ«ã‚’Eç”±ã«é…ç½®ã€Eã‚¿ãƒEEã§ç½®ãã€ã‚‚ãEã‚¿ãƒEEã§æ¶ˆã›ã¾ã™ã€‚ãƒ‰ãƒ©ãƒEä¸­ã¯ç·šã§è£œå®Œã•ã‚Œã€ç©´ãŒç©ºãã¾ã›ã‚“ã€E        </p>

        <h3 data-i18n="howtoGrowTitle">2. è‚²ã¦ã‚E(Grow)</h3>
        <p data-i18n="howtoGrowBody">
          å†ç”Ÿãƒœã‚¿ãƒ³ã§ä¸–ä»£ãŒé€²è¡Œã€‚èµ°ã‚‰ã›ãªãŒã‚‰è§¦ã‚‹ã¨è‡ªå‹•ã§ä¸€æ™‚åœæ­¢ã—ã€ãã®ã¾ã¾ç·¨é›Eãã¾ã™ã€E        </p>

        <h3 data-i18n="howtoScoreTitle">3. ã‚¹ã‚³ã‚¢ (Score)</h3>
        <p data-i18n-html="howtoScoreBody">
          ã‚¹ã‚³ã‚¢ã¯ <code>(ä¸–ä»£æ•° ÃE10) + (æœ€å¤§å€‹ä½“æ•° ÃE5)</code>ã€‚é•·ç”Ÿãã¨ç¬é–“ç«åŠ›Eä¸¡ç«‹ãŒéµã€Ebr>
          åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ«ãƒ¼ãƒ—ã«å…¥ã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒEã«ãªã‚Šã¾ã™ã€E        </p>
      </section>

      <section id="support">
        <h2 data-i18n="supportTitle">é–‹ç™ºè€Eä¸€è¨€</h2>
        <p data-i18n="supportBody">
          ä¸Eåˆã‚„ã‚¢ã‚¤ãƒEã¯ X (Twitter) ãªã©ã§ãŠçŸ¥ã‚‰ã›ãã ã•ã„ã€‚éŠã‚“ã§ãã ã•ã£ã¦ã‚ã‚ŠãŒã¨ãEã–ã„ã¾ã™ï¼E        </p>
      </section>
    </div>

    <footer>
      Â© 2025 Ikuto Yamaguchi | <a href="privacy.html">Privacy Policy</a>
    </footer>
  </div>

  <div id="game-interface" class="hidden">
    <div id="hud">
      <div class="score-display">
        <div class="score-label" id="hud-score-label" data-i18n="hudScore">SCORE</div>
        <div class="score-val" id="disp-score">0</div>
      </div>
      <div class="score-display" style="text-align: right;">
        <div class="score-label" id="hud-gen-label" data-i18n="hudGen">GENERATION</div>
        <div class="score-val" id="disp-gen">0</div>
      </div>
      <div class="score-display" id="dex-pill">
        <div class="score-label" data-i18n="dexLabel">DISCOVERY</div>
        <div class="score-val" id="dex-count">0/0</div>
      </div>
    </div>

    <div id="controls">
      <button class="ctrl-btn" id="btn-undo" title="Undo" aria-label="Undo">â†©</button>
      <button class="ctrl-btn" id="btn-redo" title="Redo" aria-label="Redo">â†ª</button>
      <button class="ctrl-btn" id="btn-reset" title="Reset" aria-label="Reset">â†»</button>
      <button class="ctrl-btn active" id="btn-toggle" title="Play/Pause" aria-label="Play/Pause">â–¶</button>
      <button class="ctrl-btn" id="btn-snap" title="Snapshot" aria-label="Snapshot">ğŸ“·</button>
      <button class="ctrl-btn" id="btn-exit-game" title="Quit" aria-label="Quit" style="border-color: #ff4444; color:#ff4444;">âœE/button>
    </div>
  </div>

  <div id="result-screen">
    <div class="result-content">
      <h2 id="res-reason" style="color:var(--secondary-color)">GAME OVER</h2>
      <div style="font-size:3.5rem; font-weight:800; margin:1rem 0;" id="res-score">0</div>
      <div class="result-meta">
        <span data-i18n="resultGen">Generations</span>: <span id="res-gen-val">0</span><br>
        <span data-i18n="resultPop">Max Pop</span>: <span id="res-pop-val">0</span>
      </div>
      <img id="res-preview" alt="Result preview" style="width:100%; border-radius:12px; border:1px solid var(--glass-border); margin-bottom:1rem; display:none;">
      <button class="btn-start" id="btn-retry" style="display:block; margin:0 auto 1.2rem auto;" data-i18n="btnRetry">RETRY</button>
      <button class="btn-start share-pulse" id="btn-share" style="display:block; margin:0 auto 0.8rem auto; background:linear-gradient(135deg, #1d9bf0, #0c7abf); font-size:1.05rem; padding:0.9rem 2.8rem;" data-i18n="btnShare">
        SHARE SCORE
      </button>
      <button style="background:none; border:none; color:white; margin-top:1rem; cursor:pointer; text-decoration:underline;" id="btn-back-home" data-i18n="backHome">Back to Home</button>
    </div>
  </div>

  <div id="toast" aria-live="polite"></div>

  <script>
    
        
    const i18n = {
      ja: {
        pageTitle: 'Life Garden | Life Game Puzzle',
        metaDesc: 'Life Garden is a simple yet deep Life Game puzzle. Place seeds, run generations, and compete with scores and beautiful patterns.',
        concept: 'Eternal Simple Fun',
        title: 'Life Garden',
        subtitle: 'Grow patterns and chase scores in a neon Game of Life playground. Simple to start, deep to master.',
        scrollHint: 'SCROLL FOR INFO',
        aboutTitle: 'What is Life Garden?',
        aboutBody: "Life Garden adapts Conway's Game of Life into a score-chasing, loop-detecting, stability-tuning browser game.",
        noteBody: 'A live cell survives with 2-3 neighbors; 3 births a new one. From this tiny rule-set, endless motion emerges.',
        howtoTitle: 'How to Play',
        howtoPlantTitle: '1. Plant',
        howtoPlantBody: 'Drag with finger or mouse to place cells. Tap once to place, tap again to erase. Dragging auto-fills gaps.',
        howtoGrowTitle: '2. Grow',
        howtoGrowBody: 'Press play to advance generations. Touch while running auto-pauses so you can edit immediately.',
        howtoScoreTitle: '3. Score',
        howtoScoreBody: 'Score = (Generations x 10) + (Max Population x 5). Balance longevity and bursts. Repeating loops end the run.',
        supportTitle: 'Feedback',
        supportBody: 'Found a bug or idea? DM on X (Twitter). Thanks for playing!',
        btnStart: 'PLAY',
        btnRetry: 'RETRY',
        btnShare: 'SHARE SCORE',
        backHome: 'Back to Home',
        hudScore: 'SCORE',
        hudGen: 'GENERATION',
        btnReset: 'Reset',
        btnPlay: 'Play',
        btnPause: 'Pause',
        btnSnap: 'Save Image',
        btnQuit: 'Quit',
        btnUndo: 'Undo',
        btnRedo: 'Redo',
        resultGen: 'Generations',
        resultPop: 'Max Pop',
        dexLabel: 'DISCOVERY',
        shareTitle: 'Life Garden Result',
        newPattern: (name) => `New pattern: ${name}`,
        reasons: {
          EXTINCTION: 'EXTINCTION',
          LOOP: 'LOOP DETECTED',
          ETERNAL: 'ETERNAL LIFE'
        },
        shareText: (gen, score) => `Survived ${gen} gens! Score: ${score} #LifeGarden`
      },
      en: {
        pageTitle: 'Life Garden | Life Game Puzzle',
        metaDesc: 'Life Garden is a simple yet deep Life Game puzzle. Place seeds, run generations, and compete with scores and beautiful patterns.',
        concept: 'Eternal Simple Fun',
        title: 'Life Garden',
        subtitle: 'Grow patterns and chase scores in a neon Game of Life playground. Simple to start, deep to master.',
        scrollHint: 'SCROLL FOR INFO',
        aboutTitle: 'What is Life Garden?',
        aboutBody: "Life Garden adapts Conway's Game of Life into a score-chasing, loop-detecting, stability-tuning browser game.",
        noteBody: 'A live cell survives with 2-3 neighbors; 3 births a new one. From this tiny rule-set, endless motion emerges.',
        howtoTitle: 'How to Play',
        howtoPlantTitle: '1. Plant',
        howtoPlantBody: 'Drag with finger or mouse to place cells. Tap once to place, tap again to erase. Dragging auto-fills gaps.',
        howtoGrowTitle: '2. Grow',
        howtoGrowBody: 'Press play to advance generations. Touch while running auto-pauses so you can edit immediately.',
        howtoScoreTitle: '3. Score',
        howtoScoreBody: 'Score = (Generations x 10) + (Max Population x 5). Balance longevity and bursts. Repeating loops end the run.',
        supportTitle: 'Feedback',
        supportBody: 'Found a bug or idea? DM on X (Twitter). Thanks for playing!',
        btnStart: 'PLAY',
        btnRetry: 'RETRY',
        btnShare: 'SHARE SCORE',
        backHome: 'Back to Home',
        hudScore: 'SCORE',
        hudGen: 'GENERATION',
        btnReset: 'Reset',
        btnPlay: 'Play',
        btnPause: 'Pause',
        btnSnap: 'Save Image',
        btnQuit: 'Quit',
        btnUndo: 'Undo',
        btnRedo: 'Redo',
        resultGen: 'Generations',
        resultPop: 'Max Pop',
        dexLabel: 'DISCOVERY',
        shareTitle: 'Life Garden Result',
        newPattern: (name) => `New pattern: ${name}`,
        reasons: {
          EXTINCTION: 'EXTINCTION',
          LOOP: 'LOOP DETECTED',
          ETERNAL: 'ETERNAL LIFE'
        },
        shareText: (gen, score) => `Survived ${gen} gens! Score: ${score} #LifeGarden`
      }
    };

const PATTERNS = [
      {
        id: 'glider',
        name: { ja: 'ã‚°ãƒ©ã‚¤ãƒ€ãƒ¼', en: 'Glider' },
        variants: [
          { cells: [[0, 1], [1, 2], [2, 0], [2, 1], [2, 2]] },
          { cells: [[0, 0], [0, 1], [0, 2], [1, 0], [2, 1]] },
          { cells: [[0, 0], [0, 1], [0, 2], [1, 2], [2, 1]] },
          { cells: [[0, 1], [1, 0], [1, 2], [2, 1], [2, 2]] }
        ]
      },
      {
        id: 'blinker',
        name: { ja: 'ãƒ–ãƒªãƒ³ã‚«ãƒ¼', en: 'Blinker' },
        variants: [
          { cells: [[0, 0], [1, 0], [2, 0]] },
          { cells: [[0, 0], [0, 1], [0, 2]] }
        ]
      },
      {
        id: 'toad',
        name: { ja: 'ãƒˆEãƒE, en: 'Toad' },
        variants: [
          { cells: [[1, 0], [2, 0], [3, 0], [0, 1], [1, 1], [2, 1]] }
        ]
      },
      {
        id: 'beacon',
        name: { ja: 'ãƒ“Eã‚³ãƒ³', en: 'Beacon' },
        variants: [
          { cells: [[0, 0], [1, 0], [0, 1], [1, 1], [2, 2], [3, 2], [2, 3], [3, 3]] }
        ]
      }
    ];

    const toast = {
      timer: null,
      show(message) {
        const el = document.getElementById('toast');
        if (!el) return;
        el.textContent = message;
        el.classList.add('visible');
        clearTimeout(this.timer);
        this.timer = setTimeout(() => el.classList.remove('visible'), 2500);
      }
    };

    const app = {
      lang: 'ja',
      isGameMode: false,

      init() {
        const savedLang = localStorage.getItem('life-garden-lang');
        if (savedLang && i18n[savedLang]) this.lang = savedLang;
        this.applyLanguage(this.lang);

        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.addEventListener('click', () => this.applyLanguage(btn.dataset.lang));
        });

        document.getElementById('hero-start-btn').addEventListener('click', () => this.enterGame());
        document.getElementById('btn-exit-game').addEventListener('click', () => this.exitGame());
        document.getElementById('btn-back-home').addEventListener('click', () => this.exitGame());
        document.getElementById('btn-retry').addEventListener('click', () => {
          document.getElementById('result-screen').classList.remove('visible');
          game.reset();
        });
        document.getElementById('btn-share').addEventListener('click', () => game.share());
        document.getElementById('btn-reset').addEventListener('click', () => game.reset());
        document.getElementById('btn-toggle').addEventListener('click', () => game.toggle());
        document.getElementById('btn-snap').addEventListener('click', () => game.snapshot());
        document.getElementById('btn-undo').addEventListener('click', () => game.undo());
        document.getElementById('btn-redo').addEventListener('click', () => game.redo());

        game.init();
      },

      applyLanguage(lang) {
        if (!i18n[lang]) return;
        this.lang = lang;
        localStorage.setItem('life-garden-lang', lang);
        document.documentElement.lang = lang;

        const dict = i18n[lang];
        document.title = dict.pageTitle;
        const metaDesc = document.querySelector('meta[name="description"]');
        if (metaDesc) metaDesc.setAttribute('content', dict.metaDesc);

        document.querySelectorAll('[data-i18n]').forEach(el => {
          const key = el.dataset.i18n;
          if (dict[key]) el.innerText = dict[key];
        });
        document.querySelectorAll('[data-i18n-html]').forEach(el => {
          const key = el.dataset.i18nHtml;
          if (dict[key]) el.innerHTML = dict[key];
        });

        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.lang === lang);
        });

        game.updateUI();
      },

      enterGame() {
        this.isGameMode = true;
        window.scrollTo(0, 0);
        document.body.classList.add('game-mode');
        document.getElementById('content-layer').classList.add('hidden');
        document.getElementById('game-interface').classList.remove('hidden');
        game.startMatch();
      },

      exitGame() {
        this.isGameMode = false;
        document.body.classList.remove('game-mode');
        document.getElementById('content-layer').classList.remove('hidden');
        document.getElementById('game-interface').classList.add('hidden');
        document.getElementById('result-screen').classList.remove('visible');
        game.toBackgroundMode();
      }
    };

    const game = {
      canvas: null,
      ctx: null,
      BASE_W: 30,
      BASE_H: 50,
      MIN_CELL: 14,

      LOGICAL_W: 30,
      LOGICAL_H: 50,
      grid: [],
      nextGrid: [],

      res: 0,
      offX: 0,
      offY: 0,
      state: 'BG', // BG, SETUP, RUNNING, RESULT
      gen: 0,
      score: 0,
      maxPop: 0,
      historySet: new Set(),
      undoStack: [],
      redoStack: [],
      maxHistory: 20,
      discovered: new Set(),
      lastShare: null,

      init() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });

        window.addEventListener('resize', () => this.resize());
        this.resize();
        this.setupInput();
        this.loadDex();
        this.toBackgroundMode();
        this.loop();
      },

      resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        this.canvas.width = w;
        this.canvas.height = h;

        const oldW = this.LOGICAL_W;
        const oldH = this.LOGICAL_H;
        const oldGrid = this.grid.map(col => [...col]);

        const allowedW = Math.max(12, Math.floor(w / this.MIN_CELL));
        const allowedH = Math.max(12, Math.floor(h / this.MIN_CELL));

        this.LOGICAL_W = Math.min(this.BASE_W, allowedW);
        this.LOGICAL_H = Math.min(this.BASE_H, allowedH);

        const resW = w / this.LOGICAL_W;
        const resH = h / this.LOGICAL_H;
        this.res = Math.min(resW, resH);

        const gridPixelW = this.LOGICAL_W * this.res;
        const gridPixelH = this.LOGICAL_H * this.res;
        this.offX = Math.floor((w - gridPixelW) / 2);
        this.offY = Math.floor((h - gridPixelH) / 2);

        const newGrid = new Array(this.LOGICAL_W).fill(0).map(() => new Array(this.LOGICAL_H).fill(0));
        const newNext = new Array(this.LOGICAL_W).fill(0).map(() => new Array(this.LOGICAL_H).fill(0));

        if (oldGrid.length) {
          const dx = Math.floor((this.LOGICAL_W - oldW) / 2);
          const dy = Math.floor((this.LOGICAL_H - oldH) / 2);
          for (let i = 0; i < oldW; i++) {
            for (let j = 0; j < oldH; j++) {
              const ni = i + dx;
              const nj = j + dy;
              if (ni >= 0 && ni < this.LOGICAL_W && nj >= 0 && nj < this.LOGICAL_H) {
                newGrid[ni][nj] = oldGrid[i][j];
              }
            }
          }
        }

        this.grid = newGrid;
        this.nextGrid = newNext;
        this.historySet.clear();

        if (this.state === 'BG' && !oldGrid.length) {
          this.randomize(0.12);
        }
      },

      toBackgroundMode() {
        this.state = 'BG';
        this.clear();
        this.randomize(0.12);
      },

      startMatch() {
        this.state = 'SETUP';
        this.clear();
        const preview = document.getElementById('res-preview');
        if (preview) preview.style.display = 'none';
        const cx = Math.floor(this.LOGICAL_W / 2);
        const cy = Math.floor(this.LOGICAL_H / 2);
        this.setCell(cx, cy, 1);
        this.setCell(cx + 1, cy, 1);
        this.setCell(cx - 1, cy, 1);
        this.setCell(cx, cy - 1, 1);
        this.setCell(cx, cy + 1, 1);
        this.resetStats();
        this.redoStack = [];
        this.pushHistory(true);
        this.updateUI();
      },

      reset() {
        if (this.state === 'BG') return;
        const preview = document.getElementById('res-preview');
        if (preview) preview.style.display = 'none';
        this.pushHistory(true);
        this.state = 'SETUP';
        this.clear();
        this.resetStats();
        this.redoStack = [];
        this.updateUI();
      },

      toggle() {
        if (this.state === 'SETUP') this.state = 'RUNNING';
        else if (this.state === 'RUNNING') this.state = 'SETUP';
        this.updateUI();
      },

      clear() {
        for (let i = 0; i < this.LOGICAL_W; i++) this.grid[i].fill(0);
      },

      setCell(x, y, val) {
        if (x >= 0 && x < this.LOGICAL_W && y >= 0 && y < this.LOGICAL_H) {
          this.grid[x][y] = val;
          this.lastShare = null;
        }
      },

      serializeGrid() {
        let res = '';
        for (let y = 0; y < this.LOGICAL_H; y++) {
          for (let x = 0; x < this.LOGICAL_W; x++) {
            res += this.grid[x][y];
          }
        }
        return res;
      },

      restoreGrid(state) {
        if (!state || state.w !== this.LOGICAL_W || state.h !== this.LOGICAL_H) return false;
        let idx = 0;
        for (let y = 0; y < state.h; y++) {
          for (let x = 0; x < state.w; x++) {
            this.grid[x][y] = Number(state.data[idx++] || 0);
          }
        }
        this.historySet.clear();
        return true;
      },

      pushHistory(force = false) {
        const snapshot = { w: this.LOGICAL_W, h: this.LOGICAL_H, data: this.serializeGrid() };
        const last = this.undoStack[this.undoStack.length - 1];
        if (force || !last || last.data !== snapshot.data) {
          this.undoStack.push(snapshot);
          if (this.undoStack.length > this.maxHistory) this.undoStack.shift();
        }
      },

      undo() {
        if (this.undoStack.length <= 1) return;
        const current = { w: this.LOGICAL_W, h: this.LOGICAL_H, data: this.serializeGrid() };
        this.redoStack.push(current);
        const prev = this.undoStack[this.undoStack.length - 2];
        this.undoStack.pop();
        this.restoreGrid(prev);
        this.lastShare = null;
      },

      redo() {
        if (this.redoStack.length === 0) return;
        const next = this.redoStack.pop();
        this.undoStack.push(next);
        this.restoreGrid(next);
        this.lastShare = null;
      },

      loadDex() {
        try {
          const raw = localStorage.getItem('life-garden-dex');
          if (raw) {
            const arr = JSON.parse(raw);
            this.discovered = new Set(arr);
          }
        } catch (e) {
          this.discovered = new Set();
        }
        this.updateDexUI();
      },

      saveDex() {
        localStorage.setItem('life-garden-dex', JSON.stringify([...this.discovered]));
      },

      updateDexUI() {
        const total = PATTERNS.length;
        const found = this.discovered.size;
        const el = document.getElementById('dex-count');
        if (el) el.innerText = `${found}/${total}`;
      },

      randomize(p) {
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            this.grid[i][j] = Math.random() < p ? 1 : 0;
          }
        }
      },

      resetStats() {
        this.gen = 0;
        this.score = 0;
        this.maxPop = 0;
        this.historySet.clear();
        this.updateHUD();
        this.updateDexUI();
      },

      getHash() {
        let res = '';
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            res += this.grid[i][j];
          }
        }
        return res;
      },

      checkPatterns() {
        const foundNow = [];
        const grid = this.grid;
        const w = this.LOGICAL_W;
        const h = this.LOGICAL_H;

        for (const pattern of PATTERNS) {
          if (this.discovered.has(pattern.id)) continue;
          for (const variant of pattern.variants) {
            const maxX = Math.max(...variant.cells.map(c => c[0]));
            const maxY = Math.max(...variant.cells.map(c => c[1]));
            for (let x = 0; x <= w - (maxX + 1); x++) {
              for (let y = 0; y <= h - (maxY + 1); y++) {
                if (this.matchesPattern(grid, x, y, variant)) {
                  foundNow.push(pattern.id);
                  this.registerPattern(pattern);
                  x = w; y = h; // break loops
                  break;
                }
              }
            }
            if (this.discovered.has(pattern.id)) break;
          }
        }
        if (foundNow.length) this.updateDexUI();
      },

      matchesPattern(grid, ox, oy, variant) {
        const required = new Set(variant.cells.map(([x, y]) => `${x},${y}`));
        const maxX = Math.max(...variant.cells.map(c => c[0]));
        const maxY = Math.max(...variant.cells.map(c => c[1]));
        for (let x = 0; x <= maxX; x++) {
          for (let y = 0; y <= maxY; y++) {
            const alive = grid[ox + x][oy + y] === 1;
            const needAlive = required.has(`${x},${y}`);
            if (needAlive !== alive) return false;
          }
        }
        return true;
      },

      registerPattern(pattern) {
        this.discovered.add(pattern.id);
        this.saveDex();
        const name = pattern.name[app.lang] || pattern.name.ja;
        const msg = i18n[app.lang].newPattern(name);
        toast.show(msg);
        this.updateDexUI();
      },

      update() {
        if (this.state !== 'RUNNING' && this.state !== 'BG') return;

        if (this.state === 'RUNNING') {
          this.lastShare = null;
        }

        let active = 0;
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            const s = this.grid[i][j];
            let sum = 0;
            for (let x = -1; x <= 1; x++) {
              for (let y = -1; y <= 1; y++) {
                if (x === 0 && y === 0) continue;
                const c = (i + x + this.LOGICAL_W) % this.LOGICAL_W;
                const r = (j + y + this.LOGICAL_H) % this.LOGICAL_H;
                sum += this.grid[c][r];
              }
            }

            if (s === 0 && sum === 3) this.nextGrid[i][j] = 1;
            else if (s === 1 && (sum < 2 || sum > 3)) this.nextGrid[i][j] = 0;
            else this.nextGrid[i][j] = s;

            if (this.nextGrid[i][j] === 1) active++;
          }
        }

        [this.grid, this.nextGrid] = [this.nextGrid, this.grid];

        if (this.state === 'RUNNING') {
          this.gen++;
          if (active > this.maxPop) this.maxPop = active;
          this.score = (this.gen * 10) + (this.maxPop * 5);
          this.updateHUD();

          if (active === 0) {
            this.gameOver('EXTINCTION');
            return;
          }

          const currentHash = this.getHash();
          if (this.historySet.has(currentHash)) {
            this.gameOver('LOOP');
            this.historySet.clear();
            return;
          }
          this.historySet.add(currentHash);
          if (this.historySet.size > 2000) this.historySet.clear();

          if (this.gen > 10000) {
            this.gameOver('ETERNAL');
            return;
          }

          if (this.gen % 5 === 0) {
            this.checkPatterns();
          }
        }
      },

      gameOver(reasonKey) {
        this.state = 'RESULT';
        const dict = i18n[app.lang];
        const reasonText = dict.reasons[reasonKey] || 'GAME OVER';
        document.getElementById('res-reason').innerText = reasonText;
        document.getElementById('res-score').innerText = this.score;
        document.getElementById('res-gen-val').innerText = this.gen;
        document.getElementById('res-pop-val').innerText = this.maxPop;
        document.getElementById('result-screen').classList.add('visible');
        this.prepareResultPreview();
      },

      async prepareResultPreview() {
        try {
          const img = await this.ensureShareImage();
          const el = document.getElementById('res-preview');
          if (el && img?.dataUrl) {
            el.src = img.dataUrl;
            el.style.display = 'block';
          }
        } catch (e) {
          console.log('Preview generation failed', e);
        }
      },

      draw() {
        this.ctx.fillStyle = '#0a0a0f';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.state !== 'BG') {
          this.ctx.fillStyle = '#0f0f16';
          this.ctx.fillRect(this.offX, this.offY, this.LOGICAL_W * this.res, this.LOGICAL_H * this.res);
          this.ctx.strokeStyle = '#2a2a35';
          this.ctx.strokeRect(this.offX, this.offY, this.LOGICAL_W * this.res, this.LOGICAL_H * this.res);
        }

        this.ctx.fillStyle = this.state === 'BG' ? '#333' : '#b249f8';
        this.ctx.shadowBlur = this.state === 'BG' ? 0 : 10;
        this.ctx.shadowColor = '#b249f8';

        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            if (this.grid[i][j] === 1) {
              const x = this.offX + i * this.res;
              const y = this.offY + j * this.res;
              this.ctx.beginPath();
              this.ctx.rect(x + 1, y + 1, this.res - 1.6, this.res - 1.6);
              this.ctx.fill();
            }
          }
        }
      },

      loop() {
        if (this.state === 'BG') {
          this.update();
        } else {
          this.update();
        }
        this.draw();
        requestAnimationFrame(() => this.loop());
      },

      setupInput() {
        let isDrag = false;
        let paintMode = 1;
        let lastPoint = null;
        let snapshotTaken = false;

        const getGridPos = (clientX, clientY) => {
          const gx = Math.floor((clientX - this.offX) / this.res);
          const gy = Math.floor((clientY - this.offY) / this.res);
          return { x: gx, y: gy };
        };

        const paintCell = (x, y, val) => {
          if (x >= 0 && x < this.LOGICAL_W && y >= 0 && y < this.LOGICAL_H) {
            this.grid[x][y] = val;
          }
        };

        const paintLine = (from, to, val) => {
          let x0 = from.x, y0 = from.y, x1 = to.x, y1 = to.y;
          const dx = Math.abs(x1 - x0);
          const dy = Math.abs(y1 - y0);
          const sx = x0 < x1 ? 1 : -1;
          const sy = y0 < y1 ? 1 : -1;
          let err = dx - dy;
          while (true) {
            paintCell(x0, y0, val);
            if (x0 === x1 && y0 === y1) break;
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
          }
        };

        const startStroke = (cx, cy) => {
          if (this.state === 'RUNNING') {
            this.state = 'SETUP';
            this.updateUI();
          }
          if (this.state !== 'SETUP' && this.state !== 'BG') return;
          if (!snapshotTaken) {
            this.pushHistory();
            this.redoStack = [];
            snapshotTaken = true;
          }

          const p = getGridPos(cx, cy);
          if (p.x >= 0 && p.x < this.LOGICAL_W && p.y >= 0 && p.y < this.LOGICAL_H) {
            isDrag = true;
            paintMode = this.grid[p.x][p.y] === 1 ? 0 : 1;
            paintCell(p.x, p.y, paintMode);
            lastPoint = p;
          }
        };

        const moveStroke = (cx, cy) => {
          if (!isDrag) return;
          const p = getGridPos(cx, cy);
          if (p.x >= 0 && p.x < this.LOGICAL_W && p.y >= 0 && p.y < this.LOGICAL_H && lastPoint) {
            paintLine(lastPoint, p, paintMode);
            lastPoint = p;
          }
        };

        const endStroke = () => {
          isDrag = false;
          lastPoint = null;
          if (snapshotTaken) {
            this.checkPatterns();
          }
          snapshotTaken = false;
        };

        this.canvas.addEventListener('pointerdown', e => {
          e.preventDefault();
          startStroke(e.clientX, e.clientY);
          this.canvas.setPointerCapture(e.pointerId);
        });
        this.canvas.addEventListener('pointermove', e => {
          if (!isDrag) return;
          e.preventDefault();
          moveStroke(e.clientX, e.clientY);
        });
        const release = e => {
          endStroke();
          if (e.pointerId !== undefined) this.canvas.releasePointerCapture(e.pointerId);
        };
        this.canvas.addEventListener('pointerup', release);
        this.canvas.addEventListener('pointercancel', release);

        window.addEventListener('keydown', e => {
          if (app.isGameMode && e.code === 'Space') {
            e.preventDefault();
            this.toggle();
          }
          if (app.isGameMode && (e.key === 'r' || e.key === 'R')) {
            e.preventDefault();
            this.reset();
          }
        });
      },

      snapshot() {
        this.ensureShareImage().then(img => {
          const a = document.createElement('a');
          a.download = `lifegarden-${this.score}.png`;
          a.href = img?.dataUrl || this.canvas.toDataURL('image/png');
          a.click();
        });
      },

      async ensureShareImage() {
        if (this.lastShare && this.lastShare.gen === this.gen && this.lastShare.score === this.score && this.lastShare.maxPop === this.maxPop) {
          return this.lastShare;
        }
        try {
          const created = await this.generateShareImage();
          this.lastShare = { ...created, gen: this.gen, score: this.score, maxPop: this.maxPop };
          return this.lastShare;
        } catch (e) {
          console.log('Share image generation failed', e);
          return null;
        }
      },

      async generateShareImage() {
        const w = 1080;
        const h = 1920;
        const c = document.createElement('canvas');
        c.width = w;
        c.height = h;
        const ctx = c.getContext('2d');

        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, '#0e0b1e');
        grad.addColorStop(1, '#1a0f2f');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);

        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fillRect(70, 120, w - 140, h - 190);

        const scale = Math.min((w - 160) / this.canvas.width, (h * 0.5) / this.canvas.height);
        const imgW = this.canvas.width * scale;
        const imgH = this.canvas.height * scale;
        const imgX = (w - imgW) / 2;
        const imgY = 160;
        ctx.drawImage(this.canvas, imgX, imgY, imgW, imgH);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 64px Outfit, sans-serif';
        ctx.fillText('Life Garden', 90, imgY + imgH + 120);
        ctx.fillStyle = '#49f8f8';
        ctx.font = '28px Outfit, sans-serif';
        ctx.fillText('Eternal Simple Fun', 90, imgY + imgH + 160);

        ctx.fillStyle = '#fff';
        ctx.font = '52px Outfit, sans-serif';
        ctx.fillText(`Score: ${this.score}`, 90, imgY + imgH + 240);
        ctx.font = '34px Outfit, sans-serif';
        ctx.fillText(`${i18n[app.lang].resultGen}: ${this.gen}`, 90, imgY + imgH + 300);
        ctx.fillText(`${i18n[app.lang].resultPop}: ${this.maxPop}`, 90, imgY + imgH + 350);

        ctx.strokeStyle = '#b249f8';
        ctx.lineWidth = 6;
        ctx.strokeRect(80, 130, w - 160, h - 210);

        const dataUrl = c.toDataURL('image/png');
        const blob = await new Promise(resolve => c.toBlob(resolve, 'image/png', 0.95));
        return { blob, dataUrl };
      },

      async share() {
        const dict = i18n[app.lang];
        const text = dict.shareText(this.gen, this.score);
        const url = "https://ikuto-yamaguchi.github.io/";

        const shareImg = await this.ensureShareImage();

        try {
          if (shareImg?.blob) {
            const file = new File([shareImg.blob], "score.png", { type: "image/png" });
            if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
              await navigator.share({
                title: dict.shareTitle,
                text,
                url,
                files: [file]
              });
              return;
            }
          }
        } catch (e) {
          console.log("Web Share API failed, falling back", e);
        }

        const downloadUrl = shareImg?.dataUrl || this.canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.download = `lifegarden-${this.score}.png`;
        a.href = downloadUrl;
        a.click();

        const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}&hashtags=LifeGarden`;
        window.open(tweetUrl, '_blank');
      },

      updateHUD() {
        document.getElementById('disp-score').innerText = this.score;
        document.getElementById('disp-gen').innerText = this.gen;
      },

      updateUI() {
        const dict = i18n[app.lang];
        const btn = document.getElementById('btn-toggle');
        const label = this.state === 'RUNNING' ? dict.btnPause : dict.btnPlay;
        btn.innerText = this.state === 'RUNNING' ? 'â¸' : 'â–¶';
        btn.setAttribute('aria-pressed', this.state === 'RUNNING');
        btn.title = label;
        btn.classList.toggle('active', this.state !== 'RUNNING');

        document.getElementById('btn-reset').title = dict.btnReset;
        document.getElementById('btn-snap').title = dict.btnSnap;
        document.getElementById('btn-exit-game').title = dict.btnQuit;
        document.getElementById('btn-exit-game').setAttribute('aria-label', dict.btnQuit);
        document.getElementById('btn-undo').title = dict.btnUndo;
        document.getElementById('btn-redo').title = dict.btnRedo;
        document.getElementById('hud-score-label').innerText = dict.hudScore;
        document.getElementById('hud-gen-label').innerText = dict.hudGen;
        document.getElementById('dex-pill').querySelector('.score-label').innerText = dict.dexLabel;
        document.getElementById('btn-share').innerText = dict.btnShare;
        document.getElementById('btn-retry').innerText = dict.btnRetry;
        document.getElementById('btn-back-home').innerText = dict.backHome;
        document.querySelector('[data-i18n="resultGen"]').innerText = dict.resultGen;
        document.querySelector('[data-i18n="resultPop"]').innerText = dict.resultPop;
      }
    };

    window.addEventListener('DOMContentLoaded', () => {
      app.init();
    });
  </script>
</body>
</html>
