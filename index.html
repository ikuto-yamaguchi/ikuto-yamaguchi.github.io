<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Life Garden | ライフゲーム育成パズル</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Life Gardenは、ライフゲームをベースにしたシンプルで奥深い育成パズル。種をまき、世代を進め、スコアと美しいパターンで競うブラウザゲームです。">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=Zen+Kaku+Gothic+New:wght@400;700&display=swap" rel="stylesheet">

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6799951658165737" crossorigin="anonymous"></script>

  <style>
    :root {
      --bg-color: #0a0a0f;
      --primary-color: #b249f8;
      --secondary-color: #49f8f8;
      --text-color: #f0f0f5;
      --glass-bg: rgba(20, 20, 30, 0.7);
      --glass-border: rgba(255, 255, 255, 0.08);
      --section-bg: rgba(30, 30, 40, 0.5);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Zen Kaku Gothic New', 'Outfit', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      width: 100%;
      height: 100%;
      overflow-x: hidden;
    }

    body {
      overflow-y: auto;
    }

    body.game-mode {
      overflow: hidden;
    }

    #game-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      touch-action: none;
      background: #05050a;
    }

    #content-layer {
      position: relative;
      z-index: 10;
      width: 100%;
      min-height: 100vh;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .hidden {
      opacity: 0 !important;
      pointer-events: none !important;
      display: none !important;
    }

    .topbar {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.5rem;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 15;
      background: linear-gradient(180deg, rgba(10, 10, 15, 0.9), rgba(10, 10, 15, 0));
      pointer-events: none;
    }

    body.game-mode .topbar {
      display: none;
    }

    .logo {
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--secondary-color);
      text-shadow: 0 0 16px rgba(73, 248, 248, 0.4);
      pointer-events: auto;
    }

    .lang-switch {
      display: flex;
      gap: 0.35rem;
      pointer-events: auto;
    }

    .lang-btn {
      border: 1px solid var(--glass-border);
      background: rgba(255, 255, 255, 0.08);
      color: #fff;
      border-radius: 14px;
      padding: 0.45rem 0.75rem;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.15s ease;
      white-space: nowrap;
    }

    .lang-btn.active {
      background: linear-gradient(135deg, var(--primary-color), #7c24cc);
      box-shadow: 0 0 12px rgba(178, 73, 248, 0.5);
    }

    .hero-section {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 3rem 1.5rem 2rem;
    }

    .hero-card {
      background: var(--glass-bg);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      padding: 3rem 2.6rem;
      border-radius: 24px;
      border: 1px solid var(--glass-border);
      max-width: 840px;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
    }

    .eyebrow {
      letter-spacing: 0.18em;
      font-size: 0.8rem;
      opacity: 0.7;
      margin-bottom: 0.6rem;
    }

    h1 {
      font-family: 'Outfit', sans-serif;
      font-size: 3.4rem;
      margin: 0 0 1rem;
      background: linear-gradient(135deg, #fff 30%, var(--primary-color) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(178, 73, 248, 0.4);
    }

    .subtitle {
      font-size: 1.2rem;
      line-height: 1.8;
      margin-bottom: 2.2rem;
      opacity: 0.9;
    }

    .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      justify-content: center;
      align-items: center;
    }

    .btn-start {
      background: linear-gradient(135deg, var(--primary-color), #7c24cc);
      color: #fff;
      border: none;
      padding: 1.1rem 3.6rem;
      font-size: 1.35rem;
      font-weight: 700;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(178, 73, 248, 0.4);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
      font-family: 'Outfit', sans-serif;
      letter-spacing: 0.04em;
      white-space: nowrap;
    }

    .btn-start:hover {
      transform: scale(1.04);
      box-shadow: 0 0 30px rgba(178, 73, 248, 0.6);
    }

    .btn-ghost {
      background: rgba(255, 255, 255, 0.08);
      color: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.14);
      padding: 0.9rem 1.6rem;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.2s ease;
    }

    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .scroll-hint {
      margin-top: 1.6rem;
      opacity: 0.65;
      font-size: 0.9rem;
      letter-spacing: 0.08em;
    }

    .privacy-container {
      margin-top: 1rem;
    }

    .btn-privacy {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 0.45rem 1.4rem;
      border-radius: 16px;
      text-decoration: none;
      font-size: 0.9rem;
      transition: all 0.2s ease;
      display: inline-block;
      white-space: nowrap;
    }

    .btn-privacy:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
      border-color: rgba(255, 255, 255, 0.35);
    }

    .container {
      max-width: 940px;
      margin: 0 auto;
      padding: 3rem 1.4rem 5rem;
    }

    section {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 2.3rem;
      margin-bottom: 2.8rem;
      border: 1px solid var(--glass-border);
    }

    h2 {
      font-size: 1.9rem;
      margin-top: 0;
      border-left: 4px solid var(--primary-color);
      padding-left: 1rem;
      color: var(--secondary-color);
    }

    h3 {
      font-size: 1.3rem;
      margin-top: 1.8rem;
      color: #fff;
    }

    p, li {
      line-height: 1.8;
      opacity: 0.92;
      font-size: 1rem;
    }

    .note {
      background: rgba(178, 73, 248, 0.14);
      border-left: 3px solid var(--primary-color);
      padding: 1rem;
      border-radius: 8px;
      margin: 1.4rem 0;
      font-size: 0.98rem;
    }

    #game-interface {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 20;
      pointer-events: none;
    }

    #hud {
      padding: 18px 20px;
      display: flex;
      justify-content: space-between;
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0.78), transparent);
      pointer-events: auto;
    }

    .score-display {
      text-align: left;
      pointer-events: auto;
    }

    .score-val {
      font-size: 2rem;
      font-weight: 800;
      font-family: 'Outfit', sans-serif;
    }

    .score-label {
      font-size: 0.82rem;
      opacity: 0.72;
      letter-spacing: 0.1em;
    }

    #dex-pill {
      text-align: right;
      min-width: 110px;
    }

    #control-panel {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      pointer-events: none;
      background: linear-gradient(180deg, rgba(10, 10, 15, 0.0), rgba(10, 10, 15, 0.65));
      padding: 0 0 8px;
    }

    #controls {
      padding: 10px 18px 12px;
      display: flex;
      justify-content: center;
      gap: 10px;
      pointer-events: auto;
      flex-wrap: wrap;
    }

    .ctrl-btn {
      min-width: 86px;
      height: 48px;
      border-radius: 14px;
      background: rgba(30, 30, 40, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.16);
      color: #fff;
      font-size: 0.95rem;
      font-weight: 700;
      cursor: pointer;
      backdrop-filter: blur(6px);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 14px;
      letter-spacing: 0.02em;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      transition: all 0.16s ease;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
    }

    #pattern-tools {
      padding: 0 18px 12px;
      pointer-events: auto;
    }

    #pattern-tools.hidden {
      display: none;
    }

    .pattern-label {
      font-size: 0.95rem;
      opacity: 0.75;
      margin-bottom: 6px;
      letter-spacing: 0.05em;
    }

    .pattern-list {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
      gap: 8px;
    }

    .pattern-btn {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15);
      color: #fff;
      padding: 10px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 700;
      letter-spacing: 0.03em;
      transition: all 0.15s ease;
    }

    .pattern-btn.active {
      background: linear-gradient(135deg, var(--secondary-color), #28bfbf);
      color: #000;
      box-shadow: 0 0 14px rgba(73, 248, 248, 0.35);
    }

    .pattern-tip {
      font-size: 0.82rem;
      opacity: 0.65;
      margin-top: 6px;
    }

    #pattern-tools.disabled {
      opacity: 0.4;
      pointer-events: none;
    }

    .ctrl-btn:hover {
      background: var(--primary-color);
      transform: translateY(-1px);
    }

    .ctrl-btn.primary {
      background: linear-gradient(135deg, var(--primary-color), #7c24cc);
      box-shadow: 0 0 12px rgba(178, 73, 248, 0.45);
    }

    .ctrl-btn.danger {
      border-color: #ff5c5c;
      color: #ff6f6f;
    }

    #result-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 20, 0.92);
      backdrop-filter: blur(10px);
      z-index: 50;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      padding: 1rem;
      overflow-y: auto;
    }

    #result-screen.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .result-content {
      background: radial-gradient(circle at 20% 20%, rgba(178,73,248,0.2), transparent 45%), var(--glass-bg);
      padding: 2.6rem;
      border-radius: 18px;
      border: 1px solid var(--glass-border);
      text-align: center;
      width: 92%;
      max-width: 820px;
      box-shadow: 0 0 50px rgba(178, 73, 248, 0.25);
    }

    .res-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1rem;
    }

    .res-pill {
      padding: 0.6rem 1rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      font-weight: 700;
      letter-spacing: 0.05em;
      color: var(--secondary-color);
      text-transform: uppercase;
    }

    .res-score-block {
      text-align: right;
      flex: 1;
    }

    .res-score-label {
      opacity: 0.65;
      letter-spacing: 0.08em;
    }

    .res-score-val {
      font-size: 3.6rem;
      font-weight: 900;
      margin-top: 4px;
      text-shadow: 0 0 24px rgba(178,73,248,0.35);
    }

    .res-meta-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin: 1.2rem 0 1.6rem;
    }

    .res-rank-msg {
      margin: 0.4rem 0 1rem;
      font-weight: 700;
      color: var(--secondary-color);
      text-align: left;
    }

    .meta-card {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px;
      padding: 0.9rem 1rem;
      text-align: left;
    }

    .meta-label {
      font-size: 0.9rem;
      opacity: 0.7;
    }

    .meta-value {
      font-size: 1.8rem;
      font-weight: 800;
      margin-top: 4px;
    }

    .res-preview-wrap {
      background: rgba(255,255,255,0.04);
      border: 1px solid var(--glass-border);
      border-radius: 14px;
      padding: 12px;
      margin-bottom: 1rem;
    }

    #res-preview {
      width: 100%;
      border-radius: 12px;
      border: 1px solid var(--glass-border);
      display: none;
    }

    .res-patterns {
      margin-top: 0.6rem;
      font-size: 0.95rem;
      opacity: 0.85;
      text-align: left;
    }

    .name-entry {
      text-align: left;
      margin: 1rem 0;
    }

    .name-entry label {
      display: block;
      font-size: 0.9rem;
      opacity: 0.75;
      margin-bottom: 6px;
    }

    .name-entry input {
      width: 100%;
      padding: 0.75rem 0.9rem;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #fff;
      font-size: 1rem;
    }

    .leaderboard {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 1rem;
      margin-bottom: 1rem;
      text-align: left;
    }

    .lb-tabs {
      display: inline-flex;
      gap: 8px;
      margin-bottom: 0.8rem;
    }

    .lb-tab {
      background: rgba(255,255,255,0.08);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.12);
      padding: 0.4rem 0.8rem;
      border-radius: 10px;
      cursor: pointer;
    }

    .lb-tab.active {
      background: linear-gradient(135deg, var(--secondary-color), #28bfbf);
      color: #000;
    }

    .lb-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 6px;
    }

    .lb-row {
      display: flex;
      justify-content: space-between;
      padding: 0.6rem 0.8rem;
      border-radius: 10px;
      background: rgba(0,0,0,0.2);
      border: 1px solid rgba(255,255,255,0.08);
      font-size: 0.95rem;
    }

    .lb-row .lb-name {
      font-weight: 700;
    }

    .lb-row .lb-score {
      font-weight: 800;
    }

    .res-actions {
      display: grid;
      gap: 0.6rem;
      margin-top: 1rem;
    }

    .result-content .btn-start,
    .result-content button {
      width: 100%;
      max-width: 420px;
      white-space: nowrap;
      margin-left: auto;
      margin-right: auto;
    }

    #toast {
      position: fixed;
      top: 18px;
      right: 18px;
      z-index: 60;
      background: rgba(20, 20, 30, 0.9);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 0.9rem 1.2rem;
      color: #fff;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.25s ease, transform 0.25s ease;
      pointer-events: none;
    }

    #toast.visible {
      opacity: 1;
      transform: translateY(0);
    }

    #dex-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.65);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 70;
    }

    #dex-modal.hidden {
      display: none;
    }

    .dex-card {
      background: var(--glass-bg);
      border: 1px solid var(--glass-border);
      border-radius: 14px;
      padding: 1rem;
      width: min(520px, 90%);
      color: #fff;
    }

    .dex-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    #dex-close {
      background: none;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      color: #fff;
      padding: 0.2rem 0.6rem;
      cursor: pointer;
    }

    #dex-list {
      list-style: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 6px;
    }

    .dex-item {
      padding: 0.6rem 0.7rem;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.95rem;
    }

    .dex-item.missing {
      opacity: 0.5;
    }

    .dex-item .dex-desc {
      font-size: 0.85rem;
      opacity: 0.75;
    }

    .share-pulse {
      animation: pulse 1.4s ease-in-out infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0px rgba(29, 155, 240, 0.6); transform: scale(1); }
      50% { box-shadow: 0 0 26px rgba(29, 155, 240, 0.7); transform: scale(1.03); }
      100% { box-shadow: 0 0 0px rgba(29, 155, 240, 0.6); transform: scale(1); }
    }

    footer {
      text-align: center;
      padding: 1.8rem;
      font-size: 0.85rem;
      opacity: 0.65;
      background: #000;
    }

    body.game-mode footer {
      display: none;
    }

    footer a {
      color: var(--secondary-color);
      text-decoration: none;
    }

    @media (max-width: 700px) {
      h1 {
        font-size: 2.4rem;
      }
      .hero-card {
        padding: 2.3rem 1.6rem;
      }
      section {
        padding: 1.6rem;
      }
      .ctrl-btn {
        min-width: 72px;
        height: 44px;
        font-size: 0.88rem;
        padding: 0 10px;
      }
      .topbar {
        padding: 0.9rem 1rem;
      }
      #controls {
        flex-wrap: wrap;
        gap: 8px;
      }
      .result-content .btn-start,
      .result-content button {
        max-width: 100%;
      }
    }

    @media (max-width: 480px) {
      .btn-start {
        font-size: 1.05rem;
        padding: 1rem 2.6rem;
      }
      .btn-privacy {
        padding: 0.85rem 1.2rem;
        font-size: 0.9rem;
      }
      .ctrl-btn {
        min-width: 68px;
        height: 42px;
        font-size: 0.82rem;
        padding: 0 8px;
      }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div class="topbar">
    <div class="logo">Life Garden</div>
    <div class="lang-switch">
      <button class="lang-btn active" data-lang="ja" aria-label="Switch to Japanese">JP</button>
      <button class="lang-btn" data-lang="en" aria-label="Switch to English">EN</button>
    </div>
  </div>

  <div id="content-layer">
        <div class="hero-section">
      <div class="hero-card">
        <div class="eyebrow" data-i18n="concept">Eternal Simple Fun</div>
        <h1 data-i18n="title">Life Garden</h1>
        <p class="subtitle" data-i18n="subtitle">
          ライフゲームの増殖パターンを「育てて」スコアを競う。シンプルで奥深い、眺めて良し・触って良しのネオン育成パズル。
        </p>
        <div class="cta-row">
          <button id="hero-start-btn" class="btn-start" data-i18n="btnStart">GAME START</button>
          <a href="privacy.html" class="btn-privacy">Privacy Policy</a>
        </div>
        <p class="scroll-hint" data-i18n="scrollHint">SCROLL FOR INFO</p>
      </div>
    </div>

    <div class="container">
      <section id="about">
        <h2 data-i18n="aboutTitle">Life Garden とは</h2>
        <p data-i18n="aboutBody">
          Life Garden は、コンウェイのライフゲームを土台にしつつ、「スコア」「ループ検知」「パターンの安定性」をゲームとして楽しめるよう調整したブラウザゲームです。
        </p>
        <div class="note" data-i18n-html="noteBody">
          生きているセルは 2〜3 個の隣接で生存、3 個で誕生。それ以外は淘汰される。たったこれだけのルールから、信じられないほど多彩な軌跡が生まれます。
        </div>
      </section>

      <section id="howto">
        <h2 data-i18n="howtoTitle">遊び方と戦略</h2>
        <h3 data-i18n="howtoPlantTitle">1. 種をまく (Plant)</h3>
        <p data-i18n="howtoPlantBody">
          盤面を指やマウスでドラッグしてセルを自由に配置。1タップで置き、もう1タップで消せます。ドラッグ中は線で補完され、穴が空きません。
        </p>

        <h3 data-i18n="howtoGrowTitle">2. 育てる (Grow)</h3>
        <p data-i18n="howtoGrowBody">
          再生ボタンで世代が進行。一度スタートしたら盤面の編集はできません。
        </p>

        <h3 data-i18n="howtoScoreTitle">3. スコア (Score)</h3>
        <p data-i18n-html="howtoScoreBody">
          スコアは <code>(世代数 × 10) + (最大個体数 × 5)</code>。長生きと瞬間火力の両立が鍵。<br>
          同じパターンのループに入るとゲームオーバーになります。
        </p>
      </section>

      <section id="support">
        <h2 data-i18n="supportTitle">開発者へ一言</h2>
        <p data-i18n="supportBody">
          不具合やアイデアは X (Twitter) などでお知らせください。遊んでくださってありがとうございます！
        </p>
      </section>
    </div>
</div>

    <footer>
      &copy; 2025 Ikuto Yamaguchi | <a href="privacy.html">Privacy Policy</a>
    </footer>
  </div>

  <div id="game-interface" class="hidden">
    <div id="hud">
      <div class="score-display">
        <div class="score-label" id="hud-score-label" data-i18n="hudScore">SCORE</div>
        <div class="score-val" id="disp-score">0</div>
      </div>
      <div class="score-display" style="text-align: right;">
        <div class="score-label" id="hud-gen-label" data-i18n="hudGen">GENERATION</div>
        <div class="score-val" id="disp-gen">0</div>
      </div>
      <div class="score-display" id="dex-pill">
        <div class="score-label" data-i18n="dexLabel">DISCOVERY</div>
        <div class="score-val" id="dex-count">0/0</div>
      </div>
    </div>

      <div id="control-panel">
        <div id="controls">
          <button class="ctrl-btn" id="btn-restore-seed" title="Restore last seed" aria-label="Restore last seed">LAST SEED</button>
          <button class="ctrl-btn" id="btn-reset" title="Reset" aria-label="Reset">RESET</button>
          <button class="ctrl-btn primary active" id="btn-toggle" title="Play/Pause" aria-label="Play/Pause">PLAY</button>
          <button class="ctrl-btn danger" id="btn-exit-game" title="Quit" aria-label="Quit">EXIT</button>
        </div>

        <div id="pattern-tools" class="hidden">
          <div class="pattern-label">Quick Place</div>
          <div class="pattern-list">
            <button class="pattern-btn" data-pattern="" id="btn-freehand">Free Draw</button>
            <button class="pattern-btn" data-pattern="single">Dot</button>
            <button class="pattern-btn" data-pattern="glider">Glider</button>
            <button class="pattern-btn" data-pattern="cross">Cross</button>
            <button class="pattern-btn" data-pattern="block">Block</button>
            <button class="pattern-btn" data-pattern="line">Line</button>
          </div>
          <div class="pattern-tip">SETUP中のみ配置できます / Free Draw でドラッグ編集</div>
        </div>
      </div>
  </div>

  <div id="result-screen">
    <div class="result-content">
      <div class="res-head">
        <div class="res-pill" id="res-reason">GAME OVER</div>
        <div class="res-score-block">
          <div class="res-score-label">TOTAL SCORE</div>
          <div class="res-score-val" id="res-score">0</div>
        </div>
      </div>

      <div class="res-meta-grid">
        <div class="meta-card">
          <div class="meta-label" data-i18n="resultGen">Generations</div>
          <div class="meta-value" id="res-gen-val">0</div>
        </div>
        <div class="meta-card">
          <div class="meta-label" data-i18n="resultPop">Max Pop</div>
          <div class="meta-value" id="res-pop-val">0</div>
        </div>
        <div class="meta-card">
          <div class="meta-label">パターン発見</div>
          <div class="meta-value" id="res-pattern-count">0</div>
        </div>
      </div>
      <div class="res-rank-msg" id="res-rank-msg"></div>

      <div class="res-preview-wrap">
        <img id="res-preview" alt="Result preview">
        <div class="res-patterns" id="res-pattern-list"></div>
      </div>

      <div class="name-entry">
        <label for="player-name">プレイヤー名</label>
        <input id="player-name" maxlength="20" placeholder="YOUR NAME">
      </div>

      <div class="leaderboard">
        <div class="lb-tabs">
          <button class="lb-tab active" data-scope="daily">デイリー</button>
          <button class="lb-tab" data-scope="weekly">ウィークリー</button>
          <button class="lb-tab" data-scope="all">通算</button>
        </div>
        <ul class="lb-list" id="lb-list"></ul>
      </div>

      <div class="res-actions">
        <button class="btn-start share-pulse" id="btn-share" data-i18n="btnShare">SHARE SCORE</button>
        <button class="btn-start" id="btn-retry" data-i18n="btnRetry">RETRY</button>
        <button class="btn-ghost" id="btn-back-home" data-i18n="backHome" style="margin-top:0.6rem;">Back to Home</button>
      </div>
    </div>
  </div>

  <div id="toast" aria-live="polite"></div>
  <div id="dex-modal" class="hidden">
    <div class="dex-card">
      <div class="dex-header">
        <h3>図鑑</h3>
        <button id="dex-close" aria-label="Close dex">×</button>
      </div>
      <ul id="dex-list"></ul>
    </div>
  </div>

  <script>
    
        
    
                        const i18n = {
  ja: {
    pageTitle: 'Life Garden | ライフゲーム育成パズル',
    metaDesc: 'Life Gardenは、ライフゲームをベースにしたシンプルで奥深い育成パズル。種をまき、世代を進め、スコアと美しいパターンで競うブラウザゲームです。',
    concept: 'Eternal Simple Fun',
    title: 'Life Garden',
    subtitle: 'ライフゲームの増殖パターンを「育てて」スコアを競う。シンプルで奥深い、眺めて良し・触って良しのネオン育成パズル。',
    scrollHint: 'SCROLL FOR INFO',
    aboutTitle: 'Life Garden とは',
    aboutBody: 'Life Garden は、コンウェイのライフゲームを土台にしつつ、「スコア」「ループ検知」「パターンの安定性」をゲームとして楽しめるよう調整したブラウザゲームです。',
    noteBody: '生きているセルは 2〜3 個の隣接で生存、3 個で誕生。それ以外は淘汰される。たったこれだけのルールから、信じられないほど多彩な軌跡が生まれます。',
    howtoTitle: '遊び方と戦略',
    howtoPlantTitle: '1. 種をまく (Plant)',
    howtoPlantBody: '盤面を指やマウスでドラッグしてセルを自由に配置。1タップで置き、もう1タップで消せます。ドラッグ中は線で補完され、穴が空きません。',
    howtoGrowTitle: '2. 育てる (Grow)',
    howtoGrowBody: '再生ボタンで世代が進行。一度スタートしたら盤面の編集はできません。',
    howtoScoreTitle: '3. スコア (Score)',
    howtoScoreBody: 'スコアは <code>(世代数 × 10) + (最大個体数 × 5)</code>。長生きと瞬間火力の両立が鍵。<br>同じパターンのループに入るとゲームオーバーになります。',
    supportTitle: '開発者へ一言',
    supportBody: '不具合やアイデアは X (Twitter) などでお知らせください。遊んでくださってありがとうございます！',
    btnStart: 'ゲームスタート',
    btnRetry: 'もう一度',
    btnShare: 'スコアをシェア',
    backHome: 'ホームに戻る',
    hudScore: 'スコア',
    hudGen: '世代',
    btnReset: 'リセット',
    btnPlay: '再生',
    btnPause: '一時停止',
    btnSnap: '画像保存',
    btnQuit: '終了',
    btnUndo: '1手戻す',
    btnRedo: 'やり直す',
    resultGen: '世代数',
    resultPop: '最大個体数',
    dexLabel: '図鑑',
    shareTitle: 'Life Garden 結果',
    newPattern: (name) => `新種発見！ ${name}`,
    reasons: {
      EXTINCTION: '全滅',
      LOOP: 'ループ検出',
      ETERNAL: 'ETERNAL LIFE'
    },
    shareText: (gen, score, maxPop) => `Life Gardenで${gen}世代生存！最大個体数${maxPop}、スコア${score} #LifeGarden`
  },
  en: {
    pageTitle: 'Life Garden | Life Game Puzzle',
    metaDesc: 'Life Garden is a simple yet deep Life Game puzzle. Place seeds, run generations, and compete with scores and beautiful patterns.',
    concept: 'Eternal Simple Fun',
    title: 'Life Garden',
    subtitle: 'Grow patterns and chase scores in a neon Game of Life playground. Simple to start, deep to master.',
    scrollHint: 'SCROLL FOR INFO',
    aboutTitle: 'What is Life Garden?',
    aboutBody: "Life Garden adapts Conway's Game of Life into a score-chasing, loop-detecting, stability-tuning browser game.",
    noteBody: 'A live cell survives with 2-3 neighbors; 3 births a new one. From this tiny rule-set, endless motion emerges.',
    howtoTitle: 'How to Play',
    howtoPlantTitle: '1. Plant',
    howtoPlantBody: 'Drag with finger or mouse to place cells. Tap once to place, tap again to erase. Dragging auto-fills gaps.',
    howtoGrowTitle: '2. Grow',
    howtoGrowBody: 'Press play to advance generations. Once running, the board cannot be edited.',
    howtoScoreTitle: '3. Score',
    howtoScoreBody: 'Score = <code>(Generations × 10) + (Max Population × 5)</code>. Balance longevity and bursts. Repeating loops end the run.',
    supportTitle: 'Feedback',
    supportBody: 'Found a bug or idea? DM on X (Twitter). Thanks for playing!',
    btnStart: 'PLAY',
    btnRetry: 'RETRY',
    btnShare: 'SHARE SCORE',
    backHome: 'Back to Home',
    hudScore: 'SCORE',
    hudGen: 'GENERATION',
    btnReset: 'Reset',
    btnPlay: 'Play',
    btnPause: 'Pause',
    btnSnap: 'Save Image',
    btnQuit: 'Quit',
    btnUndo: 'Undo',
    btnRedo: 'Redo',
    resultGen: 'Generations',
    resultPop: 'Max Pop',
    dexLabel: 'DISCOVERY',
    shareTitle: 'Life Garden Result',
    newPattern: (name) => `New pattern: ${name}`,
    reasons: {
      EXTINCTION: 'EXTINCTION',
      LOOP: 'LOOP DETECTED',
      ETERNAL: 'ETERNAL LIFE'
    },
    shareText: (gen, score, maxPop) => `Survived ${gen} gens, max pop ${maxPop}! Score: ${score} #LifeGarden`
  }
};
const PATTERNS = [
  {
    id: 'glider',
    name: { ja: 'グライダー', en: 'Glider' },
    desc: '対角に滑空し続ける往復パターン。序盤の移動用に最適。',
    variants: [
      { cells: [[0, 1], [1, 2], [2, 0], [2, 1], [2, 2]] },
      { cells: [[0, 0], [0, 1], [0, 2], [1, 0], [2, 1]] },
      { cells: [[0, 0], [0, 1], [0, 2], [1, 2], [2, 1]] },
      { cells: [[0, 1], [1, 0], [1, 2], [2, 1], [2, 2]] }
    ]
  },
  {
    id: 'blinker',
    name: { ja: 'ブリンカー', en: 'Blinker' },
    desc: '2世代で往復する基本オシレーター。安定の計測用。',
    variants: [
      { cells: [[0, 0], [1, 0], [2, 0]] },
      { cells: [[0, 0], [0, 1], [0, 2]] }
    ]
  },
  {
    id: 'toad',
    name: { ja: 'トード', en: 'Toad' },
    desc: '3x2 の周期オシレーター。密集地帯の起点に。',
    variants: [
      { cells: [[1, 0], [2, 0], [3, 0], [0, 1], [1, 1], [2, 1]] }
    ]
  },
  {
    id: 'beacon',
    name: { ja: 'ビーコン', en: 'Beacon' },
    desc: '2つのブロックが点滅。境界の作成に使える。',
    variants: [
      { cells: [[0, 0], [1, 0], [0, 1], [1, 1], [2, 2], [3, 2], [2, 3], [3, 3]] }
    ]
  }
];

const leaderboard = {
  key(scope) {
    const now = new Date();
    if (scope === 'daily') {
      return `lb-daily-${now.toISOString().slice(0, 10)}`;
    }
    if (scope === 'weekly') {
      const oneJan = new Date(now.getFullYear(), 0, 1);
      const week = Math.ceil((((now - oneJan) / 86400000) + oneJan.getDay() + 1) / 7);
      return `lb-weekly-${now.getFullYear()}-${week}`;
    }
    return 'lb-all';
  },

  load(scope) {
    try {
      const raw = localStorage.getItem(this.key(scope));
      if (raw) return JSON.parse(raw);
    } catch (e) {}
    return [];
  },

  save(scope, list) {
    localStorage.setItem(this.key(scope), JSON.stringify(list));
  },

  submit(name, score, gen, maxPop) {
    ['daily', 'weekly', 'all'].forEach(scope => {
      const list = this.load(scope);
      list.push({ name, score, gen, maxPop, ts: Date.now() });
      list.sort((a, b) => b.score - a.score || b.gen - a.gen || b.maxPop - a.maxPop || a.ts - b.ts);
      this.save(scope, list.slice(0, 10));
    });
  },

  rank(scope, name, score) {
    const list = this.load(scope);
    const idx = list.findIndex(item => item.name === name && item.score === score);
    return idx >= 0 ? idx + 1 : null;
  }
};

const toast = {
      timer: null,
      show(message) {
        const el = document.getElementById('toast');
        if (!el) return;
        el.textContent = message;
        el.classList.add('visible');
        clearTimeout(this.timer);
        this.timer = setTimeout(() => el.classList.remove('visible'), 2500);
      }
    };

    const app = {
      lang: 'ja',
      isGameMode: false,

      init() {
        const savedLang = localStorage.getItem('life-garden-lang');
        if (savedLang && i18n[savedLang]) this.lang = savedLang;
        this.applyLanguage(this.lang);

        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.addEventListener('click', () => this.applyLanguage(btn.dataset.lang));
        });

        document.getElementById('hero-start-btn').addEventListener('click', () => this.enterGame());
        document.getElementById('btn-exit-game').addEventListener('click', () => this.exitGame());
        document.getElementById('btn-back-home').addEventListener('click', () => this.exitGame());
        document.getElementById('btn-retry').addEventListener('click', () => {
          document.getElementById('result-screen').classList.remove('visible');
          game.reset();
        });
        document.getElementById('btn-share').addEventListener('click', () => game.share());
        document.getElementById('btn-reset').addEventListener('click', () => game.reset());
        document.getElementById('btn-toggle').addEventListener('click', () => game.toggle());
        document.getElementById('btn-restore-seed').addEventListener('click', () => game.restoreSavedSetup());
        document.getElementById('dex-pill').addEventListener('click', () => game.openDex());
        document.getElementById('dex-close').addEventListener('click', () => game.closeDex());
        document.getElementById('dex-modal').addEventListener('click', (e) => {
          if (e.target.id === 'dex-modal') game.closeDex();
        });

        const nameInput = document.getElementById('player-name');
        if (nameInput) {
          nameInput.addEventListener('change', () => {
            let v = nameInput.value.trim();
            if (!v) v = 'YOU';
            nameInput.value = v;
            localStorage.setItem('life-garden-name', v);
          });
        }

        document.querySelectorAll('.pattern-btn').forEach(btn => {
          btn.addEventListener('click', () => game.selectPattern(btn.dataset.pattern, btn));
        });

        document.querySelectorAll('.lb-tab').forEach(btn => {
          btn.addEventListener('click', () => game.showLeaderboard(btn.dataset.scope, btn));
        });

        game.init();
      },

      applyLanguage(lang) {
        if (!i18n[lang]) return;
        this.lang = lang;
        localStorage.setItem('life-garden-lang', lang);
        document.documentElement.lang = lang;

        const dict = i18n[lang];
        document.title = dict.pageTitle;
        const metaDesc = document.querySelector('meta[name="description"]');
        if (metaDesc) metaDesc.setAttribute('content', dict.metaDesc);

        document.querySelectorAll('[data-i18n]').forEach(el => {
          const key = el.dataset.i18n;
          if (dict[key]) el.innerText = dict[key];
        });
        document.querySelectorAll('[data-i18n-html]').forEach(el => {
          const key = el.dataset.i18nHtml;
          if (dict[key]) el.innerHTML = dict[key];
        });

        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.lang === lang);
        });

        game.updateUI();
      },

      enterGame() {
        this.isGameMode = true;
        window.scrollTo(0, 0);
        document.body.classList.add('game-mode');
        document.getElementById('content-layer').classList.add('hidden');
        document.getElementById('game-interface').classList.remove('hidden');
        document.getElementById('pattern-tools').classList.remove('hidden');
        game.getPlayerName();
        game.startMatch();
      },

      exitGame() {
        this.isGameMode = false;
        document.body.classList.remove('game-mode');
        document.getElementById('content-layer').classList.remove('hidden');
        document.getElementById('game-interface').classList.add('hidden');
        document.getElementById('result-screen').classList.remove('visible');
        document.getElementById('pattern-tools').classList.add('hidden');
        game.toBackgroundMode();
      }
    };

    const game = {
      canvas: null,
      ctx: null,
      BASE_W: 30,
      BASE_H: 50,
      MIN_CELL: 14,

      LOGICAL_W: 30,
      LOGICAL_H: 50,
      grid: [],
      nextGrid: [],

      res: 0,
      offX: 0,
      offY: 0,
      state: 'BG', // BG, SETUP, RUNNING, RESULT
      gen: 0,
      score: 0,
      maxPop: 0,
      historySet: new Set(),
      discovered: new Set(),
      foundThisRun: [],
      undoStack: [],
      redoStack: [],
      maxHistory: 20,
      savedSetup: null,
      currentPattern: null,
      palette: {
        single: [[0, 0]],
        glider: [[0, 1], [1, 2], [2, 0], [2, 1], [2, 2]],
        cross: [[0, 1], [1, 0], [1, 1], [1, 2], [2, 1]],
        block: [[0, 0], [1, 0], [0, 1], [1, 1]],
        line: [[0, 0], [1, 0], [2, 0], [3, 0]]
      },
      leaderboardScope: 'daily',
      lastShare: null,

      init() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });

        this.grid = new Array(this.LOGICAL_W).fill(0).map(() => new Array(this.LOGICAL_H).fill(0));
        this.nextGrid = new Array(this.LOGICAL_W).fill(0).map(() => new Array(this.LOGICAL_H).fill(0));

        window.addEventListener('resize', () => this.resize());
        this.resize();
        this.setupInput();
        this.loadDex();
        // プレイヤー名の初期化
        const savedName = localStorage.getItem('life-garden-name');
        if (savedName && document.getElementById('player-name')) {
          document.getElementById('player-name').value = savedName;
        }
        this.showLeaderboard(this.leaderboardScope);
        this.toBackgroundMode();
        this.loop();
      },

      resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        this.canvas.width = w;
        this.canvas.height = h;

        const resW = w / this.LOGICAL_W;
        const resH = h / this.LOGICAL_H;
        this.res = Math.min(resW, resH);

        const gridPixelW = this.LOGICAL_W * this.res;
        const gridPixelH = this.LOGICAL_H * this.res;
        this.offX = Math.floor((w - gridPixelW) / 2);
        this.offY = Math.floor((h - gridPixelH) / 2);
      },

      toBackgroundMode() {
        this.state = 'BG';
        this.clear();
        this.randomize(0.12);
      },

      startMatch() {
        this.state = 'SETUP';
        this.clear();
        const preview = document.getElementById('res-preview');
        if (preview) preview.style.display = 'none';
        const cx = Math.floor(this.LOGICAL_W / 2);
        const cy = Math.floor(this.LOGICAL_H / 2);
        this.setCell(cx, cy, 1);
        this.setCell(cx + 1, cy, 1);
        this.setCell(cx - 1, cy, 1);
        this.setCell(cx, cy - 1, 1);
        this.setCell(cx, cy + 1, 1);
        this.resetStats();
        this.redoStack = [];
        this.pushHistory(true);
        this.foundThisRun = [];
        this.saveSetupSnapshot();
        this.updateUI();
      },

      reset() {
        if (this.state === 'BG') return;
        const preview = document.getElementById('res-preview');
        if (preview) preview.style.display = 'none';
        this.pushHistory(true);
        this.state = 'SETUP';
        this.clear();
        this.resetStats();
        this.redoStack = [];
        this.foundThisRun = [];
        this.updateUI();
      },

      toggle() {
        if (this.state === 'RESULT' || this.state === 'BG') return;
        if (this.state === 'SETUP') {
          this.saveSetupSnapshot();
          this.state = 'RUNNING';
        } else if (this.state === 'RUNNING') {
          this.state = 'PAUSED';
        } else if (this.state === 'PAUSED') {
          this.state = 'RUNNING';
        }
        this.updateUI();
      },

      clear() {
        for (let i = 0; i < this.LOGICAL_W; i++) this.grid[i].fill(0);
      },

      setCell(x, y, val) {
        if (x >= 0 && x < this.LOGICAL_W && y >= 0 && y < this.LOGICAL_H) {
          this.grid[x][y] = val;
          this.lastShare = null;
        }
      },

      serializeGrid() {
        let res = '';
        for (let y = 0; y < this.LOGICAL_H; y++) {
          for (let x = 0; x < this.LOGICAL_W; x++) {
            res += this.grid[x][y];
          }
        }
        return res;
      },

      restoreGrid(state) {
        if (!state || state.w !== this.LOGICAL_W || state.h !== this.LOGICAL_H) return false;
        let idx = 0;
        for (let y = 0; y < state.h; y++) {
          for (let x = 0; x < state.w; x++) {
            this.grid[x][y] = Number(state.data[idx++] || 0);
          }
        }
        this.historySet.clear();
        return true;
      },

      saveSetupSnapshot() {
        this.savedSetup = { w: this.LOGICAL_W, h: this.LOGICAL_H, data: this.serializeGrid() };
        localStorage.setItem('life-garden-saved-setup', JSON.stringify(this.savedSetup));
      },

      loadSavedSetup() {
        if (this.savedSetup) return this.savedSetup;
        try {
          const raw = localStorage.getItem('life-garden-saved-setup');
          if (raw) this.savedSetup = JSON.parse(raw);
        } catch (e) {
          this.savedSetup = null;
        }
        return this.savedSetup;
      },

      restoreSavedSetup() {
        if (this.state !== 'SETUP') {
          toast.show('SETUP中のみ復元できます');
          return;
        }
        const snap = this.loadSavedSetup();
        if (!snap) {
          toast.show('復元できる記録がありません');
          return;
        }
        this.restoreGrid(snap);
        this.resetStats();
        toast.show('初期配置を復元しました');
        this.updateUI();
      },

      pushHistory(force = false) {
        const snapshot = { w: this.LOGICAL_W, h: this.LOGICAL_H, data: this.serializeGrid() };
        const last = this.undoStack[this.undoStack.length - 1];
        if (force || !last || last.data !== snapshot.data) {
          this.undoStack.push(snapshot);
          if (this.undoStack.length > this.maxHistory) this.undoStack.shift();
        }
      },

      undo() {
        if (this.state !== 'SETUP') return;
        if (this.undoStack.length <= 1) return;
        const current = { w: this.LOGICAL_W, h: this.LOGICAL_H, data: this.serializeGrid() };
        this.redoStack.push(current);
        const prev = this.undoStack[this.undoStack.length - 2];
        this.undoStack.pop();
        this.restoreGrid(prev);
        this.lastShare = null;
      },

      redo() {
        if (this.state !== 'SETUP') return;
        if (this.redoStack.length === 0) return;
        const next = this.redoStack.pop();
        this.undoStack.push(next);
        this.restoreGrid(next);
        this.lastShare = null;
      },

      loadDex() {
        try {
          const raw = localStorage.getItem('life-garden-dex');
          if (raw) {
            const arr = JSON.parse(raw);
            this.discovered = new Set(arr);
          }
        } catch (e) {
          this.discovered = new Set();
        }
        this.updateDexUI();
      },

      saveDex() {
        localStorage.setItem('life-garden-dex', JSON.stringify([...this.discovered]));
      },

      updateDexUI() {
        const total = PATTERNS.length;
        const found = this.discovered.size;
        const el = document.getElementById('dex-count');
        if (el) el.innerText = `${found}/${total}`;
      },

      renderDex() {
        const list = document.getElementById('dex-list');
        if (!list) return;
        list.innerHTML = '';
        PATTERNS.forEach(p => {
          const item = document.createElement('li');
          item.className = 'dex-item' + (this.discovered.has(p.id) ? '' : ' missing');
          const name = p.name[app.lang] || p.name.ja;
          const desc = p.desc || '';
          item.innerHTML = `<div><div class="dex-name">${name}</div><div class="dex-desc">${desc}</div></div><div>${this.discovered.has(p.id) ? 'FOUND' : '???'}</div>`;
          list.appendChild(item);
        });
      },

      openDex() {
        this.renderDex();
        document.getElementById('dex-modal').classList.remove('hidden');
      },

      closeDex() {
        document.getElementById('dex-modal').classList.add('hidden');
      },

      randomize(p) {
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            this.grid[i][j] = Math.random() < p ? 1 : 0;
          }
        }
      },

      resetStats() {
        this.gen = 0;
        this.score = 0;
        this.maxPop = 0;
        this.historySet.clear();
        this.updateHUD();
        this.updateDexUI();
      },

      getPlayerName() {
        const input = document.getElementById('player-name');
        let name = input?.value?.trim() || '';
        if (!name) {
          name = localStorage.getItem('life-garden-name') || 'YOU';
        }
        if (input) input.value = name;
        localStorage.setItem('life-garden-name', name);
        return name;
      },

      selectPattern(key, btn) {
        if (btn) {
          document.querySelectorAll('.pattern-btn').forEach(b => b.classList.toggle('active', b === btn));
        }
        this.currentPattern = key;
      },

      placePatternAt(cellX, cellY) {
        if (!this.currentPattern || !this.palette[this.currentPattern]) return false;
        const cells = this.palette[this.currentPattern];
        const maxX = Math.max(...cells.map(c => c[0]));
        const maxY = Math.max(...cells.map(c => c[1]));
        const offsetX = cellX - Math.floor(maxX / 2);
        const offsetY = cellY - Math.floor(maxY / 2);
        for (const [dx, dy] of cells) {
          const x = offsetX + dx;
          const y = offsetY + dy;
          if (x < 0 || y < 0 || x >= this.LOGICAL_W || y >= this.LOGICAL_H) return false;
        }
        this.pushHistory();
        this.redoStack = [];
        for (const [dx, dy] of cells) {
          const x = offsetX + dx;
          const y = offsetY + dy;
          this.grid[x][y] = 1;
        }
        this.resetStats();
        this.checkPatterns();
        return true;
      },

      getHash() {
        let res = '';
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            res += this.grid[i][j];
          }
        }
        return res;
      },

      checkPatterns() {
        const foundNow = [];
        const grid = this.grid;
        const w = this.LOGICAL_W;
        const h = this.LOGICAL_H;

        for (const pattern of PATTERNS) {
          if (this.discovered.has(pattern.id)) continue;
          for (const variant of pattern.variants) {
            const maxX = Math.max(...variant.cells.map(c => c[0]));
            const maxY = Math.max(...variant.cells.map(c => c[1]));
            for (let x = 0; x <= w - (maxX + 1); x++) {
              for (let y = 0; y <= h - (maxY + 1); y++) {
                if (this.matchesPattern(grid, x, y, variant)) {
                  foundNow.push(pattern.id);
                  this.registerPattern(pattern);
                  x = w; y = h; // break loops
                  break;
                }
              }
            }
            if (this.discovered.has(pattern.id)) break;
          }
        }
        if (foundNow.length) this.updateDexUI();
      },

      matchesPattern(grid, ox, oy, variant) {
        const required = new Set(variant.cells.map(([x, y]) => `${x},${y}`));
        const maxX = Math.max(...variant.cells.map(c => c[0]));
        const maxY = Math.max(...variant.cells.map(c => c[1]));
        for (let x = 0; x <= maxX; x++) {
          for (let y = 0; y <= maxY; y++) {
            const alive = grid[ox + x][oy + y] === 1;
            const needAlive = required.has(`${x},${y}`);
            if (needAlive !== alive) return false;
          }
        }
        return true;
      },

      registerPattern(pattern) {
        this.discovered.add(pattern.id);
        this.saveDex();
        const name = pattern.name[app.lang] || pattern.name.ja;
        const msg = i18n[app.lang].newPattern(name);
        toast.show(msg);
        if (!this.foundThisRun.includes(pattern.id)) this.foundThisRun.push(pattern.id);
        this.updateDexUI();
      },

      update() {
        if (this.state !== 'RUNNING' && this.state !== 'BG') return;

        if (this.state === 'RUNNING') {
          this.lastShare = null;
        }

        let active = 0;
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            const s = this.grid[i][j];
            let sum = 0;
            for (let x = -1; x <= 1; x++) {
              for (let y = -1; y <= 1; y++) {
                if (x === 0 && y === 0) continue;
                const c = (i + x + this.LOGICAL_W) % this.LOGICAL_W;
                const r = (j + y + this.LOGICAL_H) % this.LOGICAL_H;
                sum += this.grid[c][r];
              }
            }

            if (s === 0 && sum === 3) this.nextGrid[i][j] = 1;
            else if (s === 1 && (sum < 2 || sum > 3)) this.nextGrid[i][j] = 0;
            else this.nextGrid[i][j] = s;

            if (this.nextGrid[i][j] === 1) active++;
          }
        }

        [this.grid, this.nextGrid] = [this.nextGrid, this.grid];

        if (this.state === 'RUNNING') {
          this.gen++;
          if (active > this.maxPop) this.maxPop = active;
          this.score = (this.gen * 10) + (this.maxPop * 5);
          this.updateHUD();

          if (active === 0) {
            this.gameOver('EXTINCTION');
            return;
          }

          const currentHash = this.getHash();
          if (this.historySet.has(currentHash)) {
            this.gameOver('LOOP');
            this.historySet.clear();
            return;
          }
          this.historySet.add(currentHash);
          if (this.historySet.size > 2000) this.historySet.clear();

          if (this.gen > 10000) {
            this.gameOver('ETERNAL');
            return;
          }

          if (this.gen % 5 === 0) {
            this.checkPatterns();
          }
        }
      },

      gameOver(reasonKey) {
        this.state = 'RESULT';
        const dict = i18n[app.lang];
        const reasonText = dict.reasons[reasonKey] || 'GAME OVER';
        document.getElementById('res-reason').innerText = reasonText;
        document.getElementById('res-score').innerText = this.score;
        document.getElementById('res-gen-val').innerText = this.gen;
        document.getElementById('res-pop-val').innerText = this.maxPop;
        const patternCount = this.foundThisRun.length;
        document.getElementById('res-pattern-count').innerText = `${patternCount}`;
        const list = document.getElementById('res-pattern-list');
        if (list) {
          list.innerHTML = patternCount
            ? `発見: ${this.foundThisRun.map(id => {
              const pat = PATTERNS.find(p => p.id === id);
              return pat ? (pat.name[app.lang] || pat.name.ja) : id;
            }).join(' / ')}`
            : '発見なし';
        }

        const playerName = this.getPlayerName();
        leaderboard.submit(playerName, this.score, this.gen, this.maxPop);
        this.showLeaderboard(this.leaderboardScope);
        const rankDaily = leaderboard.rank('daily', playerName, this.score);
        const rankWeekly = leaderboard.rank('weekly', playerName, this.score);
        const rankAll = leaderboard.rank('all', playerName, this.score);
        const rankMsg = [];
        if (rankDaily) rankMsg.push(`デイリー #${rankDaily}`);
        if (rankWeekly) rankMsg.push(`ウィークリー #${rankWeekly}`);
        if (rankAll) rankMsg.push(`通算 #${rankAll}`);
        document.getElementById('res-rank-msg').innerText = rankMsg.length ? `暫定ランキング: ${rankMsg.join(' / ')}` : '記録を残して、ランキングに挑戦しよう！';
        document.getElementById('result-screen').classList.add('visible');
        this.prepareResultPreview();
      },

      async prepareResultPreview() {
        try {
          const img = await this.ensureShareImage();
          const el = document.getElementById('res-preview');
          if (el && img?.dataUrl) {
            el.src = img.dataUrl;
            el.style.display = 'block';
          }
        } catch (e) {
          console.log('Preview generation failed', e);
        }
      },

      draw() {
        this.ctx.fillStyle = '#0a0a0f';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.state !== 'BG') {
          this.ctx.fillStyle = '#0f0f16';
          this.ctx.fillRect(this.offX, this.offY, this.LOGICAL_W * this.res, this.LOGICAL_H * this.res);
          this.ctx.strokeStyle = '#2a2a35';
          this.ctx.strokeRect(this.offX, this.offY, this.LOGICAL_W * this.res, this.LOGICAL_H * this.res);
        }

        this.ctx.fillStyle = this.state === 'BG' ? '#333' : '#b249f8';
        this.ctx.shadowBlur = this.state === 'BG' ? 0 : 10;
        this.ctx.shadowColor = '#b249f8';

        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            if (this.grid[i][j] === 1) {
              const x = this.offX + i * this.res;
              const y = this.offY + j * this.res;
              this.ctx.beginPath();
              this.ctx.rect(x + 1, y + 1, this.res - 1.6, this.res - 1.6);
              this.ctx.fill();
            }
          }
        }
      },

      loop() {
        if (this.state === 'BG') {
          this.update();
        } else {
          this.update();
        }
        this.draw();
        requestAnimationFrame(() => this.loop());
      },

      setupInput() {
        let isDrag = false;
        let paintMode = 1;
        let lastPoint = null;
        let snapshotTaken = false;

        const getGridPos = (clientX, clientY) => {
          const gx = Math.floor((clientX - this.offX) / this.res);
          const gy = Math.floor((clientY - this.offY) / this.res);
          return { x: gx, y: gy };
        };

        const paintCell = (x, y, val) => {
          if (x >= 0 && x < this.LOGICAL_W && y >= 0 && y < this.LOGICAL_H) {
            this.grid[x][y] = val;
          }
        };

        const paintLine = (from, to, val) => {
          let x0 = from.x, y0 = from.y, x1 = to.x, y1 = to.y;
          const dx = Math.abs(x1 - x0);
          const dy = Math.abs(y1 - y0);
          const sx = x0 < x1 ? 1 : -1;
          const sy = y0 < y1 ? 1 : -1;
          let err = dx - dy;
          while (true) {
            paintCell(x0, y0, val);
            if (x0 === x1 && y0 === y1) break;
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
          }
        };

        const startStroke = (cx, cy) => {
          // 編集はセットアップのみ許可。RUNNING/BGでは無効。
          if (this.state !== 'SETUP') return false;
          const p = getGridPos(cx, cy);
          if (this.currentPattern && this.placePatternAt(p.x, p.y)) {
            return true;
          }
          if (!snapshotTaken) {
            this.pushHistory();
            this.redoStack = [];
            snapshotTaken = true;
          }
          if (p.x >= 0 && p.x < this.LOGICAL_W && p.y >= 0 && p.y < this.LOGICAL_H) {
            isDrag = true;
            paintMode = this.grid[p.x][p.y] === 1 ? 0 : 1;
            paintCell(p.x, p.y, paintMode);
            lastPoint = p;
            return true;
          }
          return false;
        };

        const moveStroke = (cx, cy) => {
          if (!isDrag) return;
          const p = getGridPos(cx, cy);
          if (p.x >= 0 && p.x < this.LOGICAL_W && p.y >= 0 && p.y < this.LOGICAL_H && lastPoint) {
            paintLine(lastPoint, p, paintMode);
            lastPoint = p;
          }
        };

        const endStroke = () => {
          isDrag = false;
          lastPoint = null;
          if (snapshotTaken) {
            this.checkPatterns();
          }
          snapshotTaken = false;
        };

        this.canvas.addEventListener('pointerdown', e => {
          e.preventDefault();
          const began = startStroke(e.clientX, e.clientY);
          if (began) this.canvas.setPointerCapture(e.pointerId);
        });
        this.canvas.addEventListener('pointermove', e => {
          if (!isDrag) return;
          e.preventDefault();
          moveStroke(e.clientX, e.clientY);
        });
        const release = e => {
          endStroke();
          if (e.pointerId !== undefined) this.canvas.releasePointerCapture(e.pointerId);
        };
        this.canvas.addEventListener('pointerup', release);
        this.canvas.addEventListener('pointercancel', release);

        window.addEventListener('keydown', e => {
          if (app.isGameMode && e.code === 'Space') {
            e.preventDefault();
            this.toggle();
          }
          if (app.isGameMode && (e.key === 'r' || e.key === 'R')) {
            e.preventDefault();
            this.reset();
          }
        });
      },

      snapshot() {
        this.ensureShareImage().then(img => {
          const a = document.createElement('a');
          a.download = `lifegarden-${this.score}.png`;
          a.href = img?.dataUrl || this.canvas.toDataURL('image/png');
          a.click();
        });
      },

      async ensureShareImage() {
        if (this.lastShare && this.lastShare.gen === this.gen && this.lastShare.score === this.score && this.lastShare.maxPop === this.maxPop) {
          return this.lastShare;
        }
        try {
          const created = await this.generateShareImage();
          this.lastShare = { ...created, gen: this.gen, score: this.score, maxPop: this.maxPop };
          return this.lastShare;
        } catch (e) {
          console.log('Share image generation failed', e);
          return null;
        }
      },

      async generateShareImage() {
        const w = 1080;
        const h = 1920;
        const c = document.createElement('canvas');
        c.width = w;
        c.height = h;
        const ctx = c.getContext('2d');

        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, '#0e0b1e');
        grad.addColorStop(1, '#1a0f2f');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);

        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fillRect(70, 120, w - 140, h - 190);

        const scale = Math.min((w - 160) / this.canvas.width, (h * 0.5) / this.canvas.height);
        const imgW = this.canvas.width * scale;
        const imgH = this.canvas.height * scale;
        const imgX = (w - imgW) / 2;
        const imgY = 160;
        ctx.drawImage(this.canvas, imgX, imgY, imgW, imgH);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 64px Outfit, sans-serif';
        ctx.fillText('Life Garden', 90, imgY + imgH + 120);
        ctx.fillStyle = '#49f8f8';
        ctx.font = '28px Outfit, sans-serif';
        ctx.fillText('Eternal Simple Fun', 90, imgY + imgH + 160);

        ctx.fillStyle = '#fff';
        ctx.font = '52px Outfit, sans-serif';
        ctx.fillText(`Score: ${this.score}`, 90, imgY + imgH + 240);
        ctx.font = '34px Outfit, sans-serif';
        ctx.fillText(`${i18n[app.lang].resultGen}: ${this.gen}`, 90, imgY + imgH + 300);
        ctx.fillText(`${i18n[app.lang].resultPop}: ${this.maxPop}`, 90, imgY + imgH + 350);

        ctx.strokeStyle = '#b249f8';
        ctx.lineWidth = 6;
        ctx.strokeRect(80, 130, w - 160, h - 210);

        ctx.fillStyle = '#49f8f8';
        ctx.font = '28px Outfit, sans-serif';
        ctx.fillText('#LifeGarden', 90, imgY + imgH + 400);
        ctx.fillStyle = '#ccc';
        ctx.font = '24px Outfit, sans-serif';
        ctx.fillText('Grow it. Share it. Challenge me.', 90, imgY + imgH + 440);

        const dataUrl = c.toDataURL('image/png');
        const blob = await new Promise(resolve => c.toBlob(resolve, 'image/png', 0.95));
        return { blob, dataUrl };
      },

      async share() {
        const dict = i18n[app.lang];
        const text = dict.shareText(this.gen, this.score, this.maxPop);
        const url = "https://ikuto-yamaguchi.github.io/";

        const shareImg = await this.ensureShareImage();

        try {
          if (shareImg?.blob && navigator.share && navigator.canShare) {
            const file = new File([shareImg.blob], "score.png", { type: "image/png" });
            if (navigator.canShare({ files: [file] })) {
              await navigator.share({
                title: dict.shareTitle,
                text,
                url,
                files: [file]
              });
              return;
            }
          }
        } catch (e) {
          if (e?.name === 'AbortError') {
            return; // ユーザーのキャンセル時は何もしない
          }
          console.log("Web Share API failed, falling back", e);
          toast.show('共有に失敗しました');
        }

        // Web Shareが使えない環境のみXに遷移
        if (!navigator.share) {
          const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}&hashtags=LifeGarden`;
          window.open(tweetUrl, '_blank');
        }
      },

      updateHUD() {
        document.getElementById('disp-score').innerText = this.score;
        document.getElementById('disp-gen').innerText = this.gen;
      },

      showLeaderboard(scope = 'daily', activeBtn) {
        this.leaderboardScope = scope;
        document.querySelectorAll('.lb-tab').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.scope === scope);
        });
        const ul = document.getElementById('lb-list');
        if (!ul) return;
        const list = leaderboard.load(scope);
        if (!list.length) {
          ul.innerHTML = '<li class="lb-row"><span class="lb-name">記録なし</span><span class="lb-score">-</span></li>';
          return;
        }
        ul.innerHTML = '';
        list.forEach((item, idx) => {
          const li = document.createElement('li');
          li.className = 'lb-row';
          li.innerHTML = `<span class="lb-name">${idx + 1}. ${item.name}</span><span class="lb-score">${item.score}</span>`;
          ul.appendChild(li);
        });
      },

      updateUI() {
        const dict = i18n[app.lang];
        const btn = document.getElementById('btn-toggle');
        const label = this.state === 'RUNNING' ? dict.btnPause : dict.btnPlay;
        btn.innerText = label.toUpperCase();
        btn.setAttribute('aria-pressed', this.state === 'RUNNING');
        btn.title = label;
        btn.classList.toggle('active', this.state !== 'RUNNING');

        document.getElementById('btn-reset').title = dict.btnReset;
        document.getElementById('btn-exit-game').title = dict.btnQuit;
        document.getElementById('btn-exit-game').setAttribute('aria-label', dict.btnQuit);
        document.getElementById('hud-score-label').innerText = dict.hudScore;
        document.getElementById('hud-gen-label').innerText = dict.hudGen;
        document.getElementById('dex-pill').querySelector('.score-label').innerText = dict.dexLabel;
        document.getElementById('btn-share').innerText = dict.btnShare;
        document.getElementById('btn-retry').innerText = dict.btnRetry;
        document.getElementById('btn-back-home').innerText = dict.backHome;
        document.querySelector('[data-i18n="resultGen"]').innerText = dict.resultGen;
        document.querySelector('[data-i18n="resultPop"]').innerText = dict.resultPop;

        const tools = document.getElementById('pattern-tools');
        if (tools) tools.classList.toggle('disabled', this.state !== 'SETUP');
      }
    };

    window.addEventListener('DOMContentLoaded', () => {
      app.init();
    });
  </script>
</body>
</html>
