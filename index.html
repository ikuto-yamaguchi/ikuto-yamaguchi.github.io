<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Life Garden | ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ è‚²æˆãƒ‘ã‚ºãƒ«</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Life Gardenã¯ã€ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ãŸã‚·ãƒ³ãƒ—ãƒ«ã§å¥¥æ·±ã„è‚²æˆãƒ‘ã‚ºãƒ«ã€‚ç¨®ã‚’ã¾ãã€ä¸–ä»£ã‚’é€²ã‚ã€ã‚¹ã‚³ã‚¢ã¨ç¾ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ç«¶ã†ãƒ–ãƒ©ã‚¦ã‚¶ã‚²ãƒ¼ãƒ ã§ã™ã€‚">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=Zen+Kaku+Gothic+New:wght@400;700&display=swap" rel="stylesheet">

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6799951658165737" crossorigin="anonymous"></script>

  <style>
    :root {
      --bg-color: #0a0a0f;
      --primary-color: #b249f8;
      --secondary-color: #49f8f8;
      --text-color: #f0f0f5;
      --glass-bg: rgba(20, 20, 30, 0.7);
      --glass-border: rgba(255, 255, 255, 0.08);
      --section-bg: rgba(30, 30, 40, 0.5);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Zen Kaku Gothic New', 'Outfit', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      width: 100%;
      height: 100%;
      overflow-x: hidden;
    }

    body {
      overflow-y: auto;
    }

    body.game-mode {
      overflow: hidden;
    }

    #game-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      touch-action: none;
      background: #05050a;
    }

    #content-layer {
      position: relative;
      z-index: 10;
      width: 100%;
      min-height: 100vh;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .hidden {
      opacity: 0 !important;
      pointer-events: none !important;
      display: none !important;
    }

    .topbar {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.5rem;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 15;
      background: linear-gradient(180deg, rgba(10, 10, 15, 0.9), rgba(10, 10, 15, 0));
      pointer-events: none;
    }

    .logo {
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--secondary-color);
      text-shadow: 0 0 16px rgba(73, 248, 248, 0.4);
      pointer-events: auto;
    }

    .lang-switch {
      display: flex;
      gap: 0.35rem;
      pointer-events: auto;
    }

    .lang-btn {
      border: 1px solid var(--glass-border);
      background: rgba(255, 255, 255, 0.08);
      color: #fff;
      border-radius: 14px;
      padding: 0.45rem 0.75rem;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.15s ease;
    }

    .lang-btn.active {
      background: linear-gradient(135deg, var(--primary-color), #7c24cc);
      box-shadow: 0 0 12px rgba(178, 73, 248, 0.5);
    }

    .hero-section {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 3rem 1.5rem 2rem;
    }

    .hero-card {
      background: var(--glass-bg);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      padding: 3rem 2.6rem;
      border-radius: 24px;
      border: 1px solid var(--glass-border);
      max-width: 840px;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
    }

    .eyebrow {
      letter-spacing: 0.18em;
      font-size: 0.8rem;
      opacity: 0.7;
      margin-bottom: 0.6rem;
    }

    h1 {
      font-family: 'Outfit', sans-serif;
      font-size: 3.4rem;
      margin: 0 0 1rem;
      background: linear-gradient(135deg, #fff 30%, var(--primary-color) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(178, 73, 248, 0.4);
    }

    .subtitle {
      font-size: 1.2rem;
      line-height: 1.8;
      margin-bottom: 2.2rem;
      opacity: 0.9;
    }

    .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      justify-content: center;
      align-items: center;
    }

    .btn-start {
      background: linear-gradient(135deg, var(--primary-color), #7c24cc);
      color: #fff;
      border: none;
      padding: 1.1rem 3.6rem;
      font-size: 1.35rem;
      font-weight: 700;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(178, 73, 248, 0.4);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
      font-family: 'Outfit', sans-serif;
      letter-spacing: 0.04em;
    }

    .btn-start:hover {
      transform: scale(1.04);
      box-shadow: 0 0 30px rgba(178, 73, 248, 0.6);
    }

    .btn-ghost {
      background: rgba(255, 255, 255, 0.08);
      color: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.14);
      padding: 0.9rem 1.6rem;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.2s ease;
    }

    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .scroll-hint {
      margin-top: 1.6rem;
      opacity: 0.65;
      font-size: 0.9rem;
      letter-spacing: 0.08em;
    }

    .privacy-container {
      margin-top: 1rem;
    }

    .btn-privacy {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 0.45rem 1.4rem;
      border-radius: 16px;
      text-decoration: none;
      font-size: 0.9rem;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .btn-privacy:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
      border-color: rgba(255, 255, 255, 0.35);
    }

    .container {
      max-width: 940px;
      margin: 0 auto;
      padding: 3rem 1.4rem 5rem;
    }

    section {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 2.3rem;
      margin-bottom: 2.8rem;
      border: 1px solid var(--glass-border);
    }

    h2 {
      font-size: 1.9rem;
      margin-top: 0;
      border-left: 4px solid var(--primary-color);
      padding-left: 1rem;
      color: var(--secondary-color);
    }

    h3 {
      font-size: 1.3rem;
      margin-top: 1.8rem;
      color: #fff;
    }

    p, li {
      line-height: 1.8;
      opacity: 0.92;
      font-size: 1rem;
    }

    .note {
      background: rgba(178, 73, 248, 0.14);
      border-left: 3px solid var(--primary-color);
      padding: 1rem;
      border-radius: 8px;
      margin: 1.4rem 0;
      font-size: 0.98rem;
    }

    #game-interface {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 20;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    #hud {
      padding: 18px 20px;
      display: flex;
      justify-content: space-between;
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0.78), transparent);
    }

    .score-display {
      text-align: left;
      pointer-events: auto;
    }

    .score-val {
      font-size: 2rem;
      font-weight: 800;
      font-family: 'Outfit', sans-serif;
    }

    .score-label {
      font-size: 0.82rem;
      opacity: 0.72;
      letter-spacing: 0.1em;
    }

    #controls {
      padding: 32px 16px;
      display: flex;
      justify-content: center;
      gap: 14px;
      pointer-events: auto;
    }

    .ctrl-btn {
      width: 62px;
      height: 62px;
      border-radius: 50%;
      background: rgba(30, 30, 40, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      font-size: 1.4rem;
      cursor: pointer;
      backdrop-filter: blur(6px);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.16s ease;
    }

    .ctrl-btn:hover {
      background: var(--primary-color);
      transform: translateY(-2px);
    }

    .ctrl-btn.active {
      background: var(--primary-color);
      box-shadow: 0 0 16px var(--primary-color);
    }

    #result-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 20, 0.92);
      backdrop-filter: blur(10px);
      z-index: 50;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      padding: 1rem;
    }

    #result-screen.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .result-content {
      background: var(--glass-bg);
      padding: 2.6rem;
      border-radius: 18px;
      border: 1px solid var(--glass-border);
      text-align: center;
      width: 90%;
      max-width: 520px;
      box-shadow: 0 0 50px rgba(178, 73, 248, 0.2);
    }

    .result-meta {
      margin-bottom: 1.8rem;
      opacity: 0.82;
      line-height: 1.6;
    }

    footer {
      text-align: center;
      padding: 1.8rem;
      font-size: 0.85rem;
      opacity: 0.65;
      background: #000;
    }

    footer a {
      color: var(--secondary-color);
      text-decoration: none;
    }

    @media (max-width: 700px) {
      h1 {
        font-size: 2.4rem;
      }
      .hero-card {
        padding: 2.3rem 1.6rem;
      }
      section {
        padding: 1.6rem;
      }
      .ctrl-btn {
        width: 56px;
        height: 56px;
        font-size: 1.2rem;
      }
      .topbar {
        padding: 0.9rem 1rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div class="topbar">
    <div class="logo">Life Garden</div>
    <div class="lang-switch">
      <button class="lang-btn active" data-lang="ja" aria-label="Switch to Japanese">JP</button>
      <button class="lang-btn" data-lang="en" aria-label="Switch to English">EN</button>
    </div>
  </div>

  <div id="content-layer">
    <div class="hero-section">
      <div class="hero-card">
        <div class="eyebrow" data-i18n="concept">Eternal Simple Fun</div>
        <h1 data-i18n="title">Life Garden</h1>
        <p class="subtitle" data-i18n="subtitle">
          ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã®å¢—æ®–ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã€Œè‚²ã¦ã¦ã€ã‚¹ã‚³ã‚¢ã‚’ç«¶ã†ã€‚ã‚·ãƒ³ãƒ—ãƒ«ã§å¥¥æ·±ã„ã€çœºã‚ã¦è‰¯ã—ãƒ»è§¦ã£ã¦è‰¯ã—ã®ãƒã‚ªãƒ³è‚²æˆãƒ‘ã‚ºãƒ«ã€‚
        </p>
        <div class="cta-row">
          <button id="hero-start-btn" class="btn-start" data-i18n="btnStart">GAME START</button>
          <a href="privacy.html" class="btn-privacy">Privacy Policy</a>
        </div>
        <p class="scroll-hint" data-i18n="scrollHint">â†“ SCROLL FOR INFO</p>
      </div>
    </div>

    <div class="container">
      <section id="about">
        <h2 data-i18n="aboutTitle">Life Garden ã¨ã¯</h2>
        <p data-i18n="aboutBody">
          Life Garden ã¯ã€ã‚³ãƒ³ã‚¦ã‚§ã‚¤ã®ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã‚’åœŸå°ã«ã—ã¤ã¤ã€ã€Œã‚¹ã‚³ã‚¢ã€ã€Œãƒ«ãƒ¼ãƒ—æ¤œçŸ¥ã€ã€Œãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®‰å®šæ€§ã€ã‚’ã‚²ãƒ¼ãƒ ã¨ã—ã¦æ¥½ã—ã‚ã‚‹ã‚ˆã†èª¿æ•´ã—ãŸãƒ–ãƒ©ã‚¦ã‚¶ã‚²ãƒ¼ãƒ ã§ã™ã€‚
        </p>
        <div class="note" data-i18n-html="noteBody">
          ç”Ÿãã¦ã„ã‚‹ã‚»ãƒ«ã¯ 2ã€œ3 å€‹ã®éš£æ¥ã§ç”Ÿå­˜ã€3 å€‹ã§èª•ç”Ÿã€‚ãã‚Œä»¥å¤–ã¯æ·˜æ±°ã•ã‚Œã‚‹ã€‚ãŸã£ãŸã“ã‚Œã ã‘ã®ãƒ«ãƒ¼ãƒ«ã‹ã‚‰ã€ä¿¡ã˜ã‚‰ã‚Œãªã„ã»ã©å¤šå½©ãªè»Œè·¡ãŒç”Ÿã¾ã‚Œã¾ã™ã€‚
        </div>
      </section>

      <section id="howto">
        <h2 data-i18n="howtoTitle">éŠã³æ–¹ã¨æˆ¦ç•¥</h2>
        <h3 data-i18n="howtoPlantTitle">1. ç¨®ã‚’ã¾ã (Plant)</h3>
        <p data-i18n="howtoPlantBody">
          ç›¤é¢ã‚’æŒ‡ã‚„ãƒã‚¦ã‚¹ã§ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã‚»ãƒ«ã‚’è‡ªç”±ã«é…ç½®ã€‚1ã‚¿ãƒƒãƒ—ã§ç½®ãã€ã‚‚ã†1ã‚¿ãƒƒãƒ—ã§æ¶ˆã›ã¾ã™ã€‚ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ç·šã§è£œå®Œã•ã‚Œã€ç©´ãŒç©ºãã¾ã›ã‚“ã€‚
        </p>

        <h3 data-i18n="howtoGrowTitle">2. è‚²ã¦ã‚‹ (Grow)</h3>
        <p data-i18n="howtoGrowBody">
          å†ç”Ÿãƒœã‚¿ãƒ³ã§ä¸–ä»£ãŒé€²è¡Œã€‚èµ°ã‚‰ã›ãªãŒã‚‰è§¦ã‚‹ã¨è‡ªå‹•ã§ä¸€æ™‚åœæ­¢ã—ã€ãã®ã¾ã¾ç·¨é›†ã§ãã¾ã™ã€‚
        </p>

        <h3 data-i18n="howtoScoreTitle">3. ã‚¹ã‚³ã‚¢ (Score)</h3>
        <p data-i18n-html="howtoScoreBody">
          ã‚¹ã‚³ã‚¢ã¯ <code>(ä¸–ä»£æ•° Ã— 10) + (æœ€å¤§å€‹ä½“æ•° Ã— 5)</code>ã€‚é•·ç”Ÿãã¨ç¬é–“ç«åŠ›ã®ä¸¡ç«‹ãŒéµã€‚<br>
          åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ«ãƒ¼ãƒ—ã«å…¥ã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«ãªã‚Šã¾ã™ã€‚
        </p>
      </section>

      <section id="support">
        <h2 data-i18n="supportTitle">é–‹ç™ºè€…ã¸ä¸€è¨€</h2>
        <p data-i18n="supportBody">
          ä¸å…·åˆã‚„ã‚¢ã‚¤ãƒ‡ã‚¢ã¯ X (Twitter) ãªã©ã§ãŠçŸ¥ã‚‰ã›ãã ã•ã„ã€‚éŠã‚“ã§ãã ã•ã£ã¦ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼
        </p>
      </section>
    </div>

    <footer>
      Â© 2025 Ikuto Yamaguchi | <a href="privacy.html">Privacy Policy</a>
    </footer>
  </div>

  <div id="game-interface" class="hidden">
    <div id="hud">
      <div class="score-display">
        <div class="score-label" id="hud-score-label" data-i18n="hudScore">SCORE</div>
        <div class="score-val" id="disp-score">0</div>
      </div>
      <div class="score-display" style="text-align: right;">
        <div class="score-label" id="hud-gen-label" data-i18n="hudGen">GENERATION</div>
        <div class="score-val" id="disp-gen">0</div>
      </div>
    </div>

    <div id="controls">
      <button class="ctrl-btn" id="btn-reset" title="Reset" aria-label="Reset">â†»</button>
      <button class="ctrl-btn active" id="btn-toggle" title="Play/Pause" aria-label="Play/Pause">â–¶</button>
      <button class="ctrl-btn" id="btn-snap" title="Snapshot" aria-label="Snapshot">ğŸ“·</button>
      <button class="ctrl-btn" id="btn-exit-game" title="Quit" aria-label="Quit" style="border-color: #ff4444; color:#ff4444;">âœ•</button>
    </div>
  </div>

  <div id="result-screen">
    <div class="result-content">
      <h2 id="res-reason" style="color:var(--secondary-color)">GAME OVER</h2>
      <div style="font-size:3.5rem; font-weight:800; margin:1rem 0;" id="res-score">0</div>
      <div class="result-meta">
        <span data-i18n="resultGen">Generations</span>: <span id="res-gen-val">0</span><br>
        <span data-i18n="resultPop">Max Pop</span>: <span id="res-pop-val">0</span>
      </div>
      <button class="btn-start" id="btn-retry" style="display:block; margin:0 auto 1.2rem auto;" data-i18n="btnRetry">RETRY</button>
      <button class="btn-start" id="btn-share" style="display:block; margin:0 auto 0.8rem auto; background:linear-gradient(135deg, #1d9bf0, #0c7abf); font-size:1.05rem; padding:0.9rem 2.8rem;" data-i18n="btnShare">
        SHARE SCORE
      </button>
      <button style="background:none; border:none; color:white; margin-top:1rem; cursor:pointer; text-decoration:underline;" id="btn-back-home" data-i18n="backHome">Back to Home</button>
    </div>
  </div>

  <script>
    const i18n = {
      ja: {
        pageTitle: 'Life Garden | ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ è‚²æˆãƒ‘ã‚ºãƒ«',
        metaDesc: 'Life Gardenã¯ã€ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã‚’ãƒ™ãƒ¼ã‚¹ã«ã—ãŸã‚·ãƒ³ãƒ—ãƒ«ã§å¥¥æ·±ã„è‚²æˆãƒ‘ã‚ºãƒ«ã€‚ç¨®ã‚’ã¾ãã€ä¸–ä»£ã‚’é€²ã‚ã€ã‚¹ã‚³ã‚¢ã¨ç¾ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ç«¶ã†ãƒ–ãƒ©ã‚¦ã‚¶ã‚²ãƒ¼ãƒ ã§ã™ã€‚',
        concept: 'Eternal Simple Fun',
        title: 'Life Garden',
        subtitle: 'ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã®å¢—æ®–ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ã€Œè‚²ã¦ã¦ã€ã‚¹ã‚³ã‚¢ã‚’ç«¶ã†ã€‚ã‚·ãƒ³ãƒ—ãƒ«ã§å¥¥æ·±ã„ã€çœºã‚ã¦è‰¯ã—ãƒ»è§¦ã£ã¦è‰¯ã—ã®ãƒã‚ªãƒ³è‚²æˆãƒ‘ã‚ºãƒ«ã€‚',
        scrollHint: 'â†“ SCROLL FOR INFO',
        aboutTitle: 'Life Garden ã¨ã¯',
        aboutBody: 'Life Garden ã¯ã€ã‚³ãƒ³ã‚¦ã‚§ã‚¤ã®ãƒ©ã‚¤ãƒ•ã‚²ãƒ¼ãƒ ã‚’åœŸå°ã«ã—ã¤ã¤ã€ã€Œã‚¹ã‚³ã‚¢ã€ã€Œãƒ«ãƒ¼ãƒ—æ¤œçŸ¥ã€ã€Œãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®‰å®šæ€§ã€ã‚’ã‚²ãƒ¼ãƒ ã¨ã—ã¦æ¥½ã—ã‚ã‚‹ã‚ˆã†èª¿æ•´ã—ãŸãƒ–ãƒ©ã‚¦ã‚¶ã‚²ãƒ¼ãƒ ã§ã™ã€‚',
        noteBody: 'ç”Ÿãã¦ã„ã‚‹ã‚»ãƒ«ã¯ 2ã€œ3 å€‹ã®éš£æ¥ã§ç”Ÿå­˜ã€3 å€‹ã§èª•ç”Ÿã€‚ãã‚Œä»¥å¤–ã¯æ·˜æ±°ã•ã‚Œã‚‹ã€‚ãŸã£ãŸã“ã‚Œã ã‘ã®ãƒ«ãƒ¼ãƒ«ã‹ã‚‰ã€ä¿¡ã˜ã‚‰ã‚Œãªã„ã»ã©å¤šå½©ãªè»Œè·¡ãŒç”Ÿã¾ã‚Œã¾ã™ã€‚',
        howtoTitle: 'éŠã³æ–¹ã¨æˆ¦ç•¥',
        howtoPlantTitle: '1. ç¨®ã‚’ã¾ã (Plant)',
        howtoPlantBody: 'ç›¤é¢ã‚’æŒ‡ã‚„ãƒã‚¦ã‚¹ã§ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã‚»ãƒ«ã‚’è‡ªç”±ã«é…ç½®ã€‚1ã‚¿ãƒƒãƒ—ã§ç½®ãã€ã‚‚ã†1ã‚¿ãƒƒãƒ—ã§æ¶ˆã›ã¾ã™ã€‚ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ç·šã§è£œå®Œã•ã‚Œã€ç©´ãŒç©ºãã¾ã›ã‚“ã€‚',
        howtoGrowTitle: '2. è‚²ã¦ã‚‹ (Grow)',
        howtoGrowBody: 'å†ç”Ÿãƒœã‚¿ãƒ³ã§ä¸–ä»£ãŒé€²è¡Œã€‚èµ°ã‚‰ã›ãªãŒã‚‰è§¦ã‚‹ã¨è‡ªå‹•ã§ä¸€æ™‚åœæ­¢ã—ã€ãã®ã¾ã¾ç·¨é›†ã§ãã¾ã™ã€‚',
        howtoScoreTitle: '3. ã‚¹ã‚³ã‚¢ (Score)',
        howtoScoreBody: 'ã‚¹ã‚³ã‚¢ã¯ <code>(ä¸–ä»£æ•° Ã— 10) + (æœ€å¤§å€‹ä½“æ•° Ã— 5)</code>ã€‚é•·ç”Ÿãã¨ç¬é–“ç«åŠ›ã®ä¸¡ç«‹ãŒéµã€‚<br>åŒã˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ«ãƒ¼ãƒ—ã«å…¥ã‚‹ã¨ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã«ãªã‚Šã¾ã™ã€‚',
        supportTitle: 'é–‹ç™ºè€…ã¸ä¸€è¨€',
        supportBody: 'ä¸å…·åˆã‚„ã‚¢ã‚¤ãƒ‡ã‚¢ã¯ X (Twitter) ãªã©ã§ãŠçŸ¥ã‚‰ã›ãã ã•ã„ã€‚éŠã‚“ã§ãã ã•ã£ã¦ã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼',
        btnStart: 'GAME START',
        btnRetry: 'ã‚‚ã†ä¸€åº¦',
        btnShare: 'ã‚¹ã‚³ã‚¢ã‚’ã‚·ã‚§ã‚¢',
        backHome: 'ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹',
        hudScore: 'SCORE',
        hudGen: 'GENERATION',
        btnReset: 'ãƒªã‚»ãƒƒãƒˆ',
        btnPlay: 'å†ç”Ÿ',
        btnPause: 'ä¸€æ™‚åœæ­¢',
        btnSnap: 'ç”»åƒä¿å­˜',
        btnQuit: 'çµ‚äº†',
        resultGen: 'ä¸–ä»£æ•°',
        resultPop: 'æœ€å¤§å€‹ä½“æ•°',
        reasons: {
          EXTINCTION: 'å…¨æ»…',
          LOOP: 'ãƒ«ãƒ¼ãƒ—æ¤œå‡º',
          ETERNAL: 'ETERNAL LIFE'
        },
        shareText: (gen, score) => `Life Garden ã§ ${gen} ä¸–ä»£ç”Ÿå­˜ï¼ã‚¹ã‚³ã‚¢: ${score} #LifeGarden`,
        shareTitle: 'Life Garden çµæœ'
      },
      en: {
        pageTitle: 'Life Garden | Cellular Automata Puzzle',
        metaDesc: "Life Garden is a simple yet deep puzzle built on Conway's Game of Life. Plant seeds, evolve generations, and compete with scores and mesmerizing patterns.",
        concept: 'Eternal Simple Fun',
        title: 'Life Garden',
        subtitle: 'Grow your pattern and chase high scores in a neon Game of Life playground. Simple to start, endlessly deep to master.',
        scrollHint: 'â†“ SCROLL FOR INFO',
        aboutTitle: 'What is Life Garden?',
        aboutBody: "Life Garden tweaks Conway's Game of Life into a score-chasing, loop-detecting, stability-hunting browser game.",
        noteBody: 'A live cell survives with 2â€“3 neighbors, a new cell is born with 3. Everything else dies. From this tiny rule-set, endlessly surprising motion emerges.',
        howtoTitle: 'How to Play',
        howtoPlantTitle: '1. Plant',
        howtoPlantBody: 'Drag with finger or mouse to place cells. Tap once to place, tap again to erase. Dragging auto-fills gaps.',
        howtoGrowTitle: '2. Grow',
        howtoGrowBody: 'Press play to advance generations. If you touch while running, it auto-pauses so you can edit immediately.',
        howtoScoreTitle: '3. Score',
        howtoScoreBody: 'Score = <code>(Generations Ã— 10) + (Max Population Ã— 5)</code>. Balance longevity and bursts. Hitting a repeating loop ends the run.',
        supportTitle: 'Feedback',
        supportBody: 'Spotted a bug or have an idea? Ping me on X (Twitter). Thanks for playing!',
        btnStart: 'PLAY NOW',
        btnRetry: 'RETRY',
        btnShare: 'SHARE SCORE',
        backHome: 'Back to Home',
        hudScore: 'SCORE',
        hudGen: 'GENERATION',
        btnReset: 'Reset',
        btnPlay: 'Play',
        btnPause: 'Pause',
        btnSnap: 'Save Image',
        btnQuit: 'Quit',
        resultGen: 'Generations',
        resultPop: 'Max Pop',
        reasons: {
          EXTINCTION: 'EXTINCTION',
          LOOP: 'LOOP DETECTED',
          ETERNAL: 'ETERNAL LIFE'
        },
        shareText: (gen, score) => `Survived ${gen} gens! Score: ${score} #LifeGarden`,
        shareTitle: 'Life Garden Result'
      }
    };

    const app = {
      lang: 'ja',
      isGameMode: false,

      init() {
        const savedLang = localStorage.getItem('life-garden-lang');
        if (savedLang && i18n[savedLang]) this.lang = savedLang;
        this.applyLanguage(this.lang);

        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.addEventListener('click', () => this.applyLanguage(btn.dataset.lang));
        });

        document.getElementById('hero-start-btn').addEventListener('click', () => this.enterGame());
        document.getElementById('btn-exit-game').addEventListener('click', () => this.exitGame());
        document.getElementById('btn-back-home').addEventListener('click', () => this.exitGame());
        document.getElementById('btn-retry').addEventListener('click', () => {
          document.getElementById('result-screen').classList.remove('visible');
          game.reset();
        });
        document.getElementById('btn-share').addEventListener('click', () => game.share());
        document.getElementById('btn-reset').addEventListener('click', () => game.reset());
        document.getElementById('btn-toggle').addEventListener('click', () => game.toggle());
        document.getElementById('btn-snap').addEventListener('click', () => game.snapshot());

        game.init();
      },

      applyLanguage(lang) {
        if (!i18n[lang]) return;
        this.lang = lang;
        localStorage.setItem('life-garden-lang', lang);
        document.documentElement.lang = lang;

        const dict = i18n[lang];
        document.title = dict.pageTitle;
        const metaDesc = document.querySelector('meta[name="description"]');
        if (metaDesc) metaDesc.setAttribute('content', dict.metaDesc);

        document.querySelectorAll('[data-i18n]').forEach(el => {
          const key = el.dataset.i18n;
          if (dict[key]) el.innerText = dict[key];
        });
        document.querySelectorAll('[data-i18n-html]').forEach(el => {
          const key = el.dataset.i18nHtml;
          if (dict[key]) el.innerHTML = dict[key];
        });

        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.lang === lang);
        });

        game.updateUI();
      },

      enterGame() {
        this.isGameMode = true;
        window.scrollTo(0, 0);
        document.body.classList.add('game-mode');
        document.getElementById('content-layer').classList.add('hidden');
        document.getElementById('game-interface').classList.remove('hidden');
        game.startMatch();
      },

      exitGame() {
        this.isGameMode = false;
        document.body.classList.remove('game-mode');
        document.getElementById('content-layer').classList.remove('hidden');
        document.getElementById('game-interface').classList.add('hidden');
        document.getElementById('result-screen').classList.remove('visible');
        game.toBackgroundMode();
      }
    };

    const game = {
      canvas: null,
      ctx: null,
      BASE_W: 30,
      BASE_H: 50,
      MIN_CELL: 14,

      LOGICAL_W: 30,
      LOGICAL_H: 50,
      grid: [],
      nextGrid: [],

      res: 0,
      offX: 0,
      offY: 0,
      state: 'BG', // BG, SETUP, RUNNING, RESULT
      gen: 0,
      score: 0,
      maxPop: 0,
      historySet: new Set(),

      init() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });

        window.addEventListener('resize', () => this.resize());
        this.resize();
        this.setupInput();
        this.toBackgroundMode();
        this.loop();
      },

      resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        this.canvas.width = w;
        this.canvas.height = h;

        const oldW = this.LOGICAL_W;
        const oldH = this.LOGICAL_H;
        const oldGrid = this.grid.map(col => [...col]);

        const allowedW = Math.max(12, Math.floor(w / this.MIN_CELL));
        const allowedH = Math.max(12, Math.floor(h / this.MIN_CELL));

        this.LOGICAL_W = Math.min(this.BASE_W, allowedW);
        this.LOGICAL_H = Math.min(this.BASE_H, allowedH);

        const resW = w / this.LOGICAL_W;
        const resH = h / this.LOGICAL_H;
        this.res = Math.min(resW, resH);

        const gridPixelW = this.LOGICAL_W * this.res;
        const gridPixelH = this.LOGICAL_H * this.res;
        this.offX = Math.floor((w - gridPixelW) / 2);
        this.offY = Math.floor((h - gridPixelH) / 2);

        const newGrid = new Array(this.LOGICAL_W).fill(0).map(() => new Array(this.LOGICAL_H).fill(0));
        const newNext = new Array(this.LOGICAL_W).fill(0).map(() => new Array(this.LOGICAL_H).fill(0));

        if (oldGrid.length) {
          const dx = Math.floor((this.LOGICAL_W - oldW) / 2);
          const dy = Math.floor((this.LOGICAL_H - oldH) / 2);
          for (let i = 0; i < oldW; i++) {
            for (let j = 0; j < oldH; j++) {
              const ni = i + dx;
              const nj = j + dy;
              if (ni >= 0 && ni < this.LOGICAL_W && nj >= 0 && nj < this.LOGICAL_H) {
                newGrid[ni][nj] = oldGrid[i][j];
              }
            }
          }
        }

        this.grid = newGrid;
        this.nextGrid = newNext;
        this.historySet.clear();

        if (this.state === 'BG' && !oldGrid.length) {
          this.randomize(0.12);
        }
      },

      toBackgroundMode() {
        this.state = 'BG';
        this.clear();
        this.randomize(0.12);
      },

      startMatch() {
        this.state = 'SETUP';
        this.clear();
        const cx = Math.floor(this.LOGICAL_W / 2);
        const cy = Math.floor(this.LOGICAL_H / 2);
        this.setCell(cx, cy, 1);
        this.setCell(cx + 1, cy, 1);
        this.setCell(cx - 1, cy, 1);
        this.setCell(cx, cy - 1, 1);
        this.setCell(cx, cy + 1, 1);
        this.resetStats();
        this.updateUI();
      },

      reset() {
        if (this.state === 'BG') return;
        this.state = 'SETUP';
        this.clear();
        this.resetStats();
        this.updateUI();
      },

      toggle() {
        if (this.state === 'SETUP') this.state = 'RUNNING';
        else if (this.state === 'RUNNING') this.state = 'SETUP';
        this.updateUI();
      },

      clear() {
        for (let i = 0; i < this.LOGICAL_W; i++) this.grid[i].fill(0);
      },

      setCell(x, y, val) {
        if (x >= 0 && x < this.LOGICAL_W && y >= 0 && y < this.LOGICAL_H) {
          this.grid[x][y] = val;
        }
      },

      randomize(p) {
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            this.grid[i][j] = Math.random() < p ? 1 : 0;
          }
        }
      },

      resetStats() {
        this.gen = 0;
        this.score = 0;
        this.maxPop = 0;
        this.historySet.clear();
        this.updateHUD();
      },

      getHash() {
        let res = '';
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            res += this.grid[i][j];
          }
        }
        return res;
      },

      update() {
        if (this.state !== 'RUNNING' && this.state !== 'BG') return;

        let active = 0;
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            const s = this.grid[i][j];
            let sum = 0;
            for (let x = -1; x <= 1; x++) {
              for (let y = -1; y <= 1; y++) {
                if (x === 0 && y === 0) continue;
                const c = (i + x + this.LOGICAL_W) % this.LOGICAL_W;
                const r = (j + y + this.LOGICAL_H) % this.LOGICAL_H;
                sum += this.grid[c][r];
              }
            }

            if (s === 0 && sum === 3) this.nextGrid[i][j] = 1;
            else if (s === 1 && (sum < 2 || sum > 3)) this.nextGrid[i][j] = 0;
            else this.nextGrid[i][j] = s;

            if (this.nextGrid[i][j] === 1) active++;
          }
        }

        [this.grid, this.nextGrid] = [this.nextGrid, this.grid];

        if (this.state === 'RUNNING') {
          this.gen++;
          if (active > this.maxPop) this.maxPop = active;
          this.score = (this.gen * 10) + (this.maxPop * 5);
          this.updateHUD();

          if (active === 0) {
            this.gameOver('EXTINCTION');
            return;
          }

          const currentHash = this.getHash();
          if (this.historySet.has(currentHash)) {
            this.gameOver('LOOP');
            this.historySet.clear();
            return;
          }
          this.historySet.add(currentHash);
          if (this.historySet.size > 2000) this.historySet.clear();

          if (this.gen > 10000) {
            this.gameOver('ETERNAL');
            return;
          }
        }
      },

      gameOver(reasonKey) {
        this.state = 'RESULT';
        const dict = i18n[app.lang];
        const reasonText = dict.reasons[reasonKey] || 'GAME OVER';
        document.getElementById('res-reason').innerText = reasonText;
        document.getElementById('res-score').innerText = this.score;
        document.getElementById('res-gen-val').innerText = this.gen;
        document.getElementById('res-pop-val').innerText = this.maxPop;
        document.getElementById('result-screen').classList.add('visible');
      },

      draw() {
        this.ctx.fillStyle = '#0a0a0f';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.state !== 'BG') {
          this.ctx.fillStyle = '#0f0f16';
          this.ctx.fillRect(this.offX, this.offY, this.LOGICAL_W * this.res, this.LOGICAL_H * this.res);
          this.ctx.strokeStyle = '#2a2a35';
          this.ctx.strokeRect(this.offX, this.offY, this.LOGICAL_W * this.res, this.LOGICAL_H * this.res);
        }

        this.ctx.fillStyle = this.state === 'BG' ? '#333' : '#b249f8';
        this.ctx.shadowBlur = this.state === 'BG' ? 0 : 10;
        this.ctx.shadowColor = '#b249f8';

        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            if (this.grid[i][j] === 1) {
              const x = this.offX + i * this.res;
              const y = this.offY + j * this.res;
              this.ctx.beginPath();
              this.ctx.rect(x + 1, y + 1, this.res - 1.6, this.res - 1.6);
              this.ctx.fill();
            }
          }
        }
      },

      loop() {
        if (this.state === 'BG') {
          this.update();
        } else {
          this.update();
        }
        this.draw();
        requestAnimationFrame(() => this.loop());
      },

      setupInput() {
        let isDrag = false;
        let paintMode = 1;
        let lastPoint = null;

        const getGridPos = (clientX, clientY) => {
          const gx = Math.floor((clientX - this.offX) / this.res);
          const gy = Math.floor((clientY - this.offY) / this.res);
          return { x: gx, y: gy };
        };

        const paintCell = (x, y, val) => {
          if (x >= 0 && x < this.LOGICAL_W && y >= 0 && y < this.LOGICAL_H) {
            this.grid[x][y] = val;
          }
        };

        const paintLine = (from, to, val) => {
          let x0 = from.x, y0 = from.y, x1 = to.x, y1 = to.y;
          const dx = Math.abs(x1 - x0);
          const dy = Math.abs(y1 - y0);
          const sx = x0 < x1 ? 1 : -1;
          const sy = y0 < y1 ? 1 : -1;
          let err = dx - dy;
          while (true) {
            paintCell(x0, y0, val);
            if (x0 === x1 && y0 === y1) break;
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
          }
        };

        const startStroke = (cx, cy) => {
          if (this.state === 'RUNNING') {
            this.state = 'SETUP';
            this.updateUI();
          }
          if (this.state !== 'SETUP' && this.state !== 'BG') return;

          const p = getGridPos(cx, cy);
          if (p.x >= 0 && p.x < this.LOGICAL_W && p.y >= 0 && p.y < this.LOGICAL_H) {
            isDrag = true;
            paintMode = this.grid[p.x][p.y] === 1 ? 0 : 1;
            paintCell(p.x, p.y, paintMode);
            lastPoint = p;
          }
        };

        const moveStroke = (cx, cy) => {
          if (!isDrag) return;
          const p = getGridPos(cx, cy);
          if (p.x >= 0 && p.x < this.LOGICAL_W && p.y >= 0 && p.y < this.LOGICAL_H && lastPoint) {
            paintLine(lastPoint, p, paintMode);
            lastPoint = p;
          }
        };

        const endStroke = () => {
          isDrag = false;
          lastPoint = null;
        };

        this.canvas.addEventListener('pointerdown', e => {
          e.preventDefault();
          startStroke(e.clientX, e.clientY);
          this.canvas.setPointerCapture(e.pointerId);
        });
        this.canvas.addEventListener('pointermove', e => {
          if (!isDrag) return;
          e.preventDefault();
          moveStroke(e.clientX, e.clientY);
        });
        const release = e => {
          endStroke();
          if (e.pointerId !== undefined) this.canvas.releasePointerCapture(e.pointerId);
        };
        this.canvas.addEventListener('pointerup', release);
        this.canvas.addEventListener('pointercancel', release);

        window.addEventListener('keydown', e => {
          if (app.isGameMode && e.code === 'Space') {
            e.preventDefault();
            this.toggle();
          }
          if (app.isGameMode && (e.key === 'r' || e.key === 'R')) {
            e.preventDefault();
            this.reset();
          }
        });
      },

      snapshot() {
        const d = this.canvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.download = `lifegarden-${this.score}.png`;
        a.href = d;
        a.click();
      },

      async share() {
        const dict = i18n[app.lang];
        const text = dict.shareText(this.gen, this.score);
        const url = "https://ikuto-yamaguchi.github.io/";

        try {
          const blob = await new Promise(resolve => this.canvas.toBlob(resolve));
          if (!blob) throw new Error('toBlob returned null');
          const file = new File([blob], "score.png", { type: "image/png" });

          if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
            await navigator.share({
              title: dict.shareTitle,
              text,
              url,
              files: [file]
            });
            return;
          }
        } catch (e) {
          console.log("Web Share API failed, falling back", e);
        }

        this.snapshot();
        const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}&hashtags=LifeGarden`;
        window.open(tweetUrl, '_blank');
      },

      updateHUD() {
        document.getElementById('disp-score').innerText = this.score;
        document.getElementById('disp-gen').innerText = this.gen;
      },

      updateUI() {
        const dict = i18n[app.lang];
        const btn = document.getElementById('btn-toggle');
        const label = this.state === 'RUNNING' ? dict.btnPause : dict.btnPlay;
        btn.innerText = this.state === 'RUNNING' ? 'â¸' : 'â–¶';
        btn.setAttribute('aria-pressed', this.state === 'RUNNING');
        btn.title = label;
        btn.classList.toggle('active', this.state !== 'RUNNING');

        document.getElementById('btn-reset').title = dict.btnReset;
        document.getElementById('btn-snap').title = dict.btnSnap;
        document.getElementById('btn-exit-game').title = dict.btnQuit;
        document.getElementById('btn-exit-game').setAttribute('aria-label', dict.btnQuit);
        document.getElementById('hud-score-label').innerText = dict.hudScore;
        document.getElementById('hud-gen-label').innerText = dict.hudGen;
        document.getElementById('btn-share').innerText = dict.btnShare;
        document.getElementById('btn-retry').innerText = dict.btnRetry;
        document.getElementById('btn-back-home').innerText = dict.backHome;
        document.querySelector('[data-i18n="resultGen"]').innerText = dict.resultGen;
        document.querySelector('[data-i18n="resultPop"]').innerText = dict.resultPop;
      }
    };

    window.addEventListener('DOMContentLoaded', () => {
      app.init();
    });
  </script>
</body>
</html>
