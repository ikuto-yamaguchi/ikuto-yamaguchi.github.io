<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Life Garden | ライフゲーム育成パズル</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Life Gardenは、ライフゲームをベースにしたシンプルで奥深い育成パズル。種をまき、世代を進め、スコアと美しいパターンで競うブラウザゲームです。">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=Zen+Kaku+Gothic+New:wght@400;700&display=swap" rel="stylesheet">

  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6799951658165737" crossorigin="anonymous"></script>

  <style>
    :root {
      --bg-color: #0a0a0f;
      --primary-color: #b249f8;
      --secondary-color: #49f8f8;
      --text-color: #f0f0f5;
      --glass-bg: rgba(20, 20, 30, 0.7);
      --glass-border: rgba(255, 255, 255, 0.08);
      --section-bg: rgba(30, 30, 40, 0.5);
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Zen Kaku Gothic New', 'Outfit', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      width: 100%;
      height: 100%;
      overflow-x: hidden;
    }

    body {
      overflow-y: auto;
    }

    body.game-mode {
      overflow: hidden;
    }

    #game-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      touch-action: none;
      background: #05050a;
    }

    #content-layer {
      position: relative;
      z-index: 10;
      width: 100%;
      min-height: 100vh;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }

    .hidden {
      opacity: 0 !important;
      pointer-events: none !important;
      display: none !important;
    }

    .topbar {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.5rem;
      position: fixed;
      top: 0;
      left: 0;
      z-index: 15;
      background: linear-gradient(180deg, rgba(10, 10, 15, 0.9), rgba(10, 10, 15, 0));
      pointer-events: none;
    }

    body.game-mode .topbar {
      display: none;
    }

    .logo {
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--secondary-color);
      text-shadow: 0 0 16px rgba(73, 248, 248, 0.4);
      pointer-events: auto;
    }

    .lang-switch {
      display: flex;
      gap: 0.35rem;
      pointer-events: auto;
    }

    .lang-btn {
      border: 1px solid var(--glass-border);
      background: rgba(255, 255, 255, 0.08);
      color: #fff;
      border-radius: 14px;
      padding: 0.45rem 0.75rem;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.15s ease;
    }

    .lang-btn.active {
      background: linear-gradient(135deg, var(--primary-color), #7c24cc);
      box-shadow: 0 0 12px rgba(178, 73, 248, 0.5);
    }

    .hero-section {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 3rem 1.5rem 2rem;
    }

    .hero-card {
      background: var(--glass-bg);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      padding: 3rem 2.6rem;
      border-radius: 24px;
      border: 1px solid var(--glass-border);
      max-width: 840px;
      box-shadow: 0 18px 60px rgba(0, 0, 0, 0.55);
    }

    .eyebrow {
      letter-spacing: 0.18em;
      font-size: 0.8rem;
      opacity: 0.7;
      margin-bottom: 0.6rem;
    }

    h1 {
      font-family: 'Outfit', sans-serif;
      font-size: 3.4rem;
      margin: 0 0 1rem;
      background: linear-gradient(135deg, #fff 30%, var(--primary-color) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(178, 73, 248, 0.4);
    }

    .subtitle {
      font-size: 1.2rem;
      line-height: 1.8;
      margin-bottom: 2.2rem;
      opacity: 0.9;
    }

    .cta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.8rem;
      justify-content: center;
      align-items: center;
    }

    .btn-start {
      background: linear-gradient(135deg, var(--primary-color), #7c24cc);
      color: #fff;
      border: none;
      padding: 1.1rem 3.6rem;
      font-size: 1.35rem;
      font-weight: 700;
      border-radius: 999px;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(178, 73, 248, 0.4);
      transition: transform 0.18s ease, box-shadow 0.18s ease;
      font-family: 'Outfit', sans-serif;
      letter-spacing: 0.04em;
    }

    .btn-start:hover {
      transform: scale(1.04);
      box-shadow: 0 0 30px rgba(178, 73, 248, 0.6);
    }

    .btn-ghost {
      background: rgba(255, 255, 255, 0.08);
      color: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.14);
      padding: 0.9rem 1.6rem;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.2s ease;
    }

    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .scroll-hint {
      margin-top: 1.6rem;
      opacity: 0.65;
      font-size: 0.9rem;
      letter-spacing: 0.08em;
    }

    .privacy-container {
      margin-top: 1rem;
    }

    .btn-privacy {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.8);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 0.45rem 1.4rem;
      border-radius: 16px;
      text-decoration: none;
      font-size: 0.9rem;
      transition: all 0.2s ease;
      display: inline-block;
    }

    .btn-privacy:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #fff;
      border-color: rgba(255, 255, 255, 0.35);
    }

    .container {
      max-width: 940px;
      margin: 0 auto;
      padding: 3rem 1.4rem 5rem;
    }

    section {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 2.3rem;
      margin-bottom: 2.8rem;
      border: 1px solid var(--glass-border);
    }

    h2 {
      font-size: 1.9rem;
      margin-top: 0;
      border-left: 4px solid var(--primary-color);
      padding-left: 1rem;
      color: var(--secondary-color);
    }

    h3 {
      font-size: 1.3rem;
      margin-top: 1.8rem;
      color: #fff;
    }

    p, li {
      line-height: 1.8;
      opacity: 0.92;
      font-size: 1rem;
    }

    .note {
      background: rgba(178, 73, 248, 0.14);
      border-left: 3px solid var(--primary-color);
      padding: 1rem;
      border-radius: 8px;
      margin: 1.4rem 0;
      font-size: 0.98rem;
    }

    #game-interface {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 20;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    #hud {
      padding: 18px 20px;
      display: flex;
      justify-content: space-between;
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0.78), transparent);
    }

    .score-display {
      text-align: left;
      pointer-events: auto;
    }

    .score-val {
      font-size: 2rem;
      font-weight: 800;
      font-family: 'Outfit', sans-serif;
    }

    .score-label {
      font-size: 0.82rem;
      opacity: 0.72;
      letter-spacing: 0.1em;
    }

    #dex-pill {
      text-align: right;
      min-width: 110px;
    }

    #controls {
      padding: 20px 18px 26px;
      display: flex;
      justify-content: center;
      gap: 10px;
      pointer-events: auto;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(10, 10, 15, 0.8), rgba(10, 10, 15, 0.4));
    }

    .ctrl-btn {
      min-width: 86px;
      height: 48px;
      border-radius: 14px;
      background: rgba(30, 30, 40, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.16);
      color: #fff;
      font-size: 0.95rem;
      font-weight: 700;
      cursor: pointer;
      backdrop-filter: blur(6px);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0 14px;
      letter-spacing: 0.02em;
      transition: all 0.16s ease;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
    }

    .ctrl-btn:hover {
      background: var(--primary-color);
      transform: translateY(-1px);
    }

    .ctrl-btn.primary {
      background: linear-gradient(135deg, var(--primary-color), #7c24cc);
      box-shadow: 0 0 12px rgba(178, 73, 248, 0.45);
    }

    .ctrl-btn.danger {
      border-color: #ff5c5c;
      color: #ff6f6f;
    }

    #result-screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 10, 20, 0.92);
      backdrop-filter: blur(10px);
      z-index: 50;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      padding: 1rem;
      overflow-y: auto;
    }

    #result-screen.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .result-content {
      background: var(--glass-bg);
      padding: 2.6rem;
      border-radius: 18px;
      border: 1px solid var(--glass-border);
      text-align: center;
      width: 90%;
      max-width: 520px;
      box-shadow: 0 0 50px rgba(178, 73, 248, 0.2);
    }

    .result-meta {
      margin-bottom: 1.8rem;
      opacity: 0.82;
      line-height: 1.6;
    }

    .result-content .btn-start,
    .result-content button {
      width: 100%;
      max-width: 420px;
    }

    #toast {
      position: fixed;
      top: 18px;
      right: 18px;
      z-index: 60;
      background: rgba(20, 20, 30, 0.9);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 0.9rem 1.2rem;
      color: #fff;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.35);
      opacity: 0;
      transform: translateY(-10px);
      transition: opacity 0.25s ease, transform 0.25s ease;
      pointer-events: none;
    }

    #toast.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .share-pulse {
      animation: pulse 1.4s ease-in-out infinite;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0px rgba(29, 155, 240, 0.6); transform: scale(1); }
      50% { box-shadow: 0 0 26px rgba(29, 155, 240, 0.7); transform: scale(1.03); }
      100% { box-shadow: 0 0 0px rgba(29, 155, 240, 0.6); transform: scale(1); }
    }

    footer {
      text-align: center;
      padding: 1.8rem;
      font-size: 0.85rem;
      opacity: 0.65;
      background: #000;
    }

    footer a {
      color: var(--secondary-color);
      text-decoration: none;
    }

    @media (max-width: 700px) {
      h1 {
        font-size: 2.4rem;
      }
      .hero-card {
        padding: 2.3rem 1.6rem;
      }
      section {
        padding: 1.6rem;
      }
      .ctrl-btn {
        min-width: 72px;
        height: 44px;
        font-size: 0.9rem;
        padding: 0 10px;
      }
      .topbar {
        padding: 0.9rem 1rem;
      }
      #controls {
        flex-wrap: wrap;
        gap: 8px;
      }
      .result-content .btn-start,
      .result-content button {
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
  <canvas id="game-canvas"></canvas>

  <div class="topbar">
    <div class="logo">Life Garden</div>
    <div class="lang-switch">
      <button class="lang-btn active" data-lang="ja" aria-label="Switch to Japanese">JP</button>
      <button class="lang-btn" data-lang="en" aria-label="Switch to English">EN</button>
    </div>
  </div>

  <div id="content-layer">
    <div class="hero-section">
      <div class="hero-card">
        <div class="eyebrow" data-i18n="concept">Eternal Simple Fun</div>
        <h1 data-i18n="title">Life Garden</h1>
        <p class="subtitle" data-i18n="subtitle">
          繝ｩ繧､繝輔ご繝ｼ繝縺ｮ蠅玲ｮ悶ヱ繧ｿ繝ｼ繝ｳ繧偵瑚ご縺ｦ縺ｦ縲阪せ繧ｳ繧｢繧堤ｫｶ縺・繧ｷ繝ｳ繝励Ν縺ｧ螂･豺ｱ縺・逵ｺ繧√※濶ｯ縺勇隗ｦ縺｣縺ｦ濶ｯ縺勇繝阪が繝ｳ閧ｲ謌舌ヱ繧ｺ繝ｫ縲・        </p>
        <div class="cta-row">
          <button id="hero-start-btn" class="btn-start" data-i18n="btnStart">GAME START</button>
          <a href="privacy.html" class="btn-privacy">Privacy Policy</a>
        </div>
        <p class="scroll-hint" data-i18n="scrollHint">竊・SCROLL FOR INFO</p>
      </div>
    </div>

    <div class="container">
      <section id="about">
        <h2 data-i18n="aboutTitle">Life Garden 縺ｨ縺ｯ</h2>
        <p data-i18n="aboutBody">
          Life Garden 縺ｯ縲√さ繝ｳ繧ｦ繧ｧ繧､縺ｮ繝ｩ繧､繝輔ご繝ｼ繝繧貞悄蜿ｰ縺ｫ縺励▽縺､縲√後せ繧ｳ繧｢縲阪後Ν繝ｼ繝玲､懃衍縲阪後ヱ繧ｿ繝ｼ繝ｳ縺ｮ螳牙ｮ壽ｧ縲阪ｒ繧ｲ繝ｼ繝縺ｨ縺励※讌ｽ縺励ａ繧九ｈ縺・謨ｴ縺励◆繝悶Λ繧ｦ繧ｶ繧ｲ繝ｼ繝縺ｧ縺吶・        </p>
        <div class="note" data-i18n-html="noteBody">
          逕溘″縺ｦ縺・繧ｻ繝ｫ縺ｯ 2縲・ 蛟畿髫｣謗･縺ｧ逕溷ｭ倥・ 蛟九〒隱慕函縲ゅ◎繧御ｻ･螟胞豺俶ｱｰ縺輔ｌ繧九ゅ◆縺｣縺溘％繧後□縺薦繝ｫ繝ｼ繝ｫ縺九ｉ縲∽ｿ｡縺倥ｉ繧後↑縺・縺ｩ螟壼ｽｩ縺ｪ霆瑚ｷ｡縺檎函縺ｾ繧後∪縺吶・        </div>
      </section>

      <section id="howto">
        <h2 data-i18n="howtoTitle">驕界譁ｹ縺ｨ謌ｦ逡･</h2>
        <h3 data-i18n="howtoPlantTitle">1. 遞ｮ繧偵∪縺・(Plant)</h3>
        <p data-i18n="howtoPlantBody">
          逶､髱｢繧呈欠繧・E繧ｦ繧ｹ縺ｧ繝峨Λ繝・縺励※繧ｻ繝ｫ繧脱逕ｱ縺ｫ驟咲ｽｮ縲・繧ｿ繝・E縺ｧ鄂ｮ縺阪√ｂ縺・繧ｿ繝・E縺ｧ豸医○縺ｾ縺吶ゅラ繝ｩ繝・荳ｭ縺ｯ邱壹〒陬懷ｮ後＆繧後∫ｩｴ縺檎ｩｺ縺阪∪縺帙ｓ縲・        </p>

        <h3 data-i18n="howtoGrowTitle">2. 閧ｲ縺ｦ繧・(Grow)</h3>
        <p data-i18n="howtoGrowBody">
          蜀咲函繝懊ち繝ｳ縺ｧ荳紋ｻ｣縺碁ｲ陦後りｵｰ繧峨○縺ｪ縺後ｉ隗ｦ繧九→閾ｪ蜍輔〒荳譎ょ●豁｢縺励√◎縺ｮ縺ｾ縺ｾ邱ｨ髮・縺阪∪縺吶・        </p>

        <h3 data-i18n="howtoScoreTitle">3. 繧ｹ繧ｳ繧｢ (Score)</h3>
        <p data-i18n-html="howtoScoreBody">
          繧ｹ繧ｳ繧｢縺ｯ <code>(荳紋ｻ｣謨ｰ ﾃ・10) + (譛螟ｧ蛟倶ｽ捺焚 ﾃ・5)</code>縲る聞逕溘″縺ｨ迸ｬ髢鍋↓蜉妣荳｡遶九′骰ｵ縲・br>
          蜷後§繝代ち繝ｼ繝ｳ縺ｮ繝ｫ繝ｼ繝励↓蜈･繧九→繧ｲ繝ｼ繝繧ｪ繝ｼ繝職縺ｫ縺ｪ繧翫∪縺吶・        </p>
      </section>

      <section id="support">
        <h2 data-i18n="supportTitle">髢狗匱閠・荳險</h2>
        <p data-i18n="supportBody">
          荳孔蜷医ｄ繧｢繧､繝・縺ｯ X (Twitter) 縺ｪ縺ｩ縺ｧ縺顔衍繧峨○縺上□縺輔＞縲る♀繧薙〒縺上□縺輔▲縺ｦ縺ゅｊ縺後→縺・縺悶＞縺ｾ縺呻ｼ・        </p>
      </section>
    </div>

    <footer>
      ﾂｩ 2025 Ikuto Yamaguchi | <a href="privacy.html">Privacy Policy</a>
    </footer>
  </div>

  <div id="game-interface" class="hidden">
    <div id="hud">
      <div class="score-display">
        <div class="score-label" id="hud-score-label" data-i18n="hudScore">SCORE</div>
        <div class="score-val" id="disp-score">0</div>
      </div>
      <div class="score-display" style="text-align: right;">
        <div class="score-label" id="hud-gen-label" data-i18n="hudGen">GENERATION</div>
        <div class="score-val" id="disp-gen">0</div>
      </div>
      <div class="score-display" id="dex-pill">
        <div class="score-label" data-i18n="dexLabel">DISCOVERY</div>
        <div class="score-val" id="dex-count">0/0</div>
      </div>
    </div>

    <div id="controls">
      <button class="ctrl-btn" id="btn-undo" title="Undo" aria-label="Undo">UNDO</button>
      <button class="ctrl-btn" id="btn-redo" title="Redo" aria-label="Redo">REDO</button>
      <button class="ctrl-btn" id="btn-reset" title="Reset" aria-label="Reset">RESET</button>
      <button class="ctrl-btn primary active" id="btn-toggle" title="Play/Pause" aria-label="Play/Pause">PLAY</button>
      <button class="ctrl-btn" id="btn-snap" title="Snapshot" aria-label="Snapshot">SAVE</button>
      <button class="ctrl-btn danger" id="btn-exit-game" title="Quit" aria-label="Quit">EXIT</button>
    </div>
  </div>

  <div id="result-screen">
    <div class="result-content">
      <h2 id="res-reason" style="color:var(--secondary-color)">GAME OVER</h2>
      <div style="font-size:3.5rem; font-weight:800; margin:1rem 0;" id="res-score">0</div>
      <div class="result-meta">
        <span data-i18n="resultGen">Generations</span>: <span id="res-gen-val">0</span><br>
        <span data-i18n="resultPop">Max Pop</span>: <span id="res-pop-val">0</span>
      </div>
      <img id="res-preview" alt="Result preview" style="width:100%; border-radius:12px; border:1px solid var(--glass-border); margin-bottom:1rem; display:none;">
      <button class="btn-start" id="btn-retry" style="display:block; margin:0 auto 1.2rem auto;" data-i18n="btnRetry">RETRY</button>
      <button class="btn-start share-pulse" id="btn-share" style="display:block; margin:0 auto 0.8rem auto; background:linear-gradient(135deg, #1d9bf0, #0c7abf); font-size:1.05rem; padding:0.9rem 2.8rem;" data-i18n="btnShare">
        SHARE SCORE
      </button>
      <button style="background:none; border:none; color:white; margin-top:1rem; cursor:pointer; text-decoration:underline;" id="btn-back-home" data-i18n="backHome">Back to Home</button>
    </div>
  </div>

  <div id="toast" aria-live="polite"></div>

  <script>
    
        
    
                        const i18n = {
  "ja": {
    "pageTitle": "Life Garden | ã©ã¤ãã²ã¼ã è²æããºã«",
    "metaDesc": "Life Gardenã¯ãã©ã¤ãã²ã¼ã ããã¼ã¹ã«ããã·ã³ãã«ã§å¥¥æ·±ãè²æããºã«ãç¨®ãã¾ããä¸ä»£ãé²ããã¹ã³ã¢ã¨ç¾ãããã¿ã¼ã³ã§ç«¶ããã©ã¦ã¶ã²ã¼ã ã§ãã",
    "concept": "Eternal Simple Fun",
    "title": "Life Garden",
    "subtitle": "ã©ã¤ãã²ã¼ã ã®å¢æ®ãã¿ã¼ã³ããè²ã¦ã¦ãã¹ã³ã¢ãç«¶ããã·ã³ãã«ã§å¥¥æ·±ããçãã°æ¥½ããÂ·è§¦ã£ã¦æ¥½ããããªã³è²æããºã«ã",
    "scrollHint": "? SCROLL FOR INFO",
    "aboutTitle": "Life Garden ã¨ã¯",
    "aboutBody": "Life Garden ã¯ãã³ã³ã¦ã§ã¤ã®ã©ã¤ãã²ã¼ã ãåå°ã«ãã¤ã¤ããã¹ã³ã¢ããã«ã¼ãæ¤ç¥ãããã¿ã¼ã³ã®å®å®æ§ããã²ã¼ã ã¨ãã¦æ¥½ãããããèª¿æ´ãããã©ã¦ã¶ã²ã¼ã ã§ãã",
    "noteBody": "çãã¦ããã»ã«ã¯ 2ï½3 åã®é£æ¥ã§çå­ã3 åã§èªçãããä»¥å¤ã¯æ·æ±°ãããããã£ãããã ãã®ã«ã¼ã«ãããä¿¡ããããªãã»ã©å¤å½©ãªè»è·¡ãçã¾ãã¾ãã",
    "howtoTitle": "éã³æ¹ã¨æ¦ç¥",
    "howtoPlantTitle": "1. ç¨®ãã¾ã (Plant)",
    "howtoPlantBody": "ç¤é¢ãæããã¦ã¹ã§ãã©ãã°ãã¦ã»ã«ãèªç±ã«é
ç½®ã1ã¿ããã§ç½®ãããã1ã¿ããã§æ¶ãã¾ãããã©ãã°ä¸­ã¯ç·ã§è£å®ãããç©ºããåºã¾ããã",
    "howtoGrowTitle": "2. è²ã¦ã (Grow)",
    "howtoGrowBody": "åçãã¿ã³ã§ä¸ä»£ãé²è¡ãä¸åº¦ã¹ã¿ã¼ããããç¤é¢ã®ç·¨éã¯ã§ãã¾ããã",
    "howtoScoreTitle": "3. ??? (Score)",
    "howtoScoreBody": "???? <code>(??? ? 10) + (????? ? 5)</code>???????????????<br>???????????????????????????",
    "supportTitle": "??????",
    "supportBody": "????????? X (Twitter) ???????????????????????????????",
    "btnStart": "???????",
    "btnRetry": "????",
    "btnShare": "???????",
    "backHome": "??????",
    "hudScore": "???",
    "hudGen": "??",
    "btnReset": "????",
    "btnPlay": "??",
    "btnPause": "????",
    "btnSnap": "????",
    "btnQuit": "??",
    "btnUndo": "1???",
    "btnRedo": "????",
    "resultGen": "???",
    "resultPop": "?????",
    "dexLabel": "??",
    "shareTitle": "Life Garden ??",
    "newPattern": (name) => `New pattern: ${name}`,
    "reasons": {
      "EXTINCTION": "??",
      "LOOP": "?????",
      "ETERNAL": "ETERNAL LIFE"
    },
    "shareText": (gen, score, maxPop) => `Life Gardenã§${gen}ä¸ä»£çå­ï¼æå¤§åä½æ°${maxPop}ãã¹ã³ã¢${score} #LifeGarden`
  },
  "en": {
    "pageTitle": "Life Garden | Life Game Puzzle",
    "metaDesc": "Life Garden is a simple yet deep Life Game puzzle. Place seeds, run generations, and compete with scores and beautiful patterns.",
    "concept": "Eternal Simple Fun",
    "title": "Life Garden",
    "subtitle": "Grow patterns and chase scores in a neon Game of Life playground. Simple to start, deep to master.",
    "scrollHint": "SCROLL FOR INFO",
    "aboutTitle": "What is Life Garden?",
    "aboutBody": "Life Garden adapts Conway's Game of Life into a score-chasing, loop-detecting, stability-tuning browser game.",
    "noteBody": "A live cell survives with 2-3 neighbors; 3 births a new one. From this tiny rule-set, endless motion emerges.",
    "howtoTitle": "How to Play",
    "howtoPlantTitle": "1. Plant",
    "howtoPlantBody": "Drag with finger or mouse to place cells. Tap once to place, tap again to erase. Dragging auto-fills gaps.",
    "howtoGrowTitle": "2. Grow",
    "howtoGrowBody": "Press play to advance generations. Once running, the board cannot be edited.",
    "howtoScoreTitle": "3. Score",
    "howtoScoreBody": "Score = <code>(Generations ? 10) + (Max Population ? 5)</code>. Balance longevity and bursts. Repeating loops end the run.",
    "supportTitle": "Feedback",
    "supportBody": "Found a bug or idea? DM on X (Twitter). Thanks for playing!",
    "btnStart": "PLAY",
    "btnRetry": "RETRY",
    "btnShare": "SHARE SCORE",
    "backHome": "Back to Home",
    "hudScore": "SCORE",
    "hudGen": "GENERATION",
    "btnReset": "Reset",
    "btnPlay": "Play",
    "btnPause": "Pause",
    "btnSnap": "Save Image",
    "btnQuit": "Quit",
    "btnUndo": "Undo",
    "btnRedo": "Redo",
    "resultGen": "Generations",
    "resultPop": "Max Pop",
    "dexLabel": "DISCOVERY",
    "shareTitle": "Life Garden Result",
    "newPattern": (name) => `New pattern: ${name}`,
    "reasons": {
      "EXTINCTION": "EXTINCTION",
      "LOOP": "LOOP DETECTED",
      "ETERNAL": "ETERNAL LIFE"
    },
    "shareText": (gen, score, maxPop) => `Survived ${gen} gens, max pop ${maxPop}! Score: ${score} #LifeGarden`
  }
};
const PATTERNS = [
      {
        id: 'glider',
        name: { ja: '繧ｰ繝ｩ繧､繝繝ｼ', en: 'Glider' },
        variants: [
          { cells: [[0, 1], [1, 2], [2, 0], [2, 1], [2, 2]] },
          { cells: [[0, 0], [0, 1], [0, 2], [1, 0], [2, 1]] },
          { cells: [[0, 0], [0, 1], [0, 2], [1, 2], [2, 1]] },
          { cells: [[0, 1], [1, 0], [1, 2], [2, 1], [2, 2]] }
        ]
      },
      {
        id: 'blinker',
        name: { ja: '繝悶Μ繝ｳ繧ｫ繝ｼ', en: 'Blinker' },
        variants: [
          { cells: [[0, 0], [1, 0], [2, 0]] },
          { cells: [[0, 0], [0, 1], [0, 2]] }
        ]
      },
      {
        id: 'toad',
        name: { ja: 'トード', en: 'Toad' },
        variants: [
          { cells: [[1, 0], [2, 0], [3, 0], [0, 1], [1, 1], [2, 1]] }
        ]
      },
      {
        id: 'beacon',
        name: { ja: 'ビーコン', en: 'Beacon' },
        variants: [
          { cells: [[0, 0], [1, 0], [0, 1], [1, 1], [2, 2], [3, 2], [2, 3], [3, 3]] }
        ]
      }
    ];

    const toast = {
      timer: null,
      show(message) {
        const el = document.getElementById('toast');
        if (!el) return;
        el.textContent = message;
        el.classList.add('visible');
        clearTimeout(this.timer);
        this.timer = setTimeout(() => el.classList.remove('visible'), 2500);
      }
    };

    const app = {
      lang: 'ja',
      isGameMode: false,

      init() {
        const savedLang = localStorage.getItem('life-garden-lang');
        if (savedLang && i18n[savedLang]) this.lang = savedLang;
        this.applyLanguage(this.lang);

        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.addEventListener('click', () => this.applyLanguage(btn.dataset.lang));
        });

        document.getElementById('hero-start-btn').addEventListener('click', () => this.enterGame());
        document.getElementById('btn-exit-game').addEventListener('click', () => this.exitGame());
        document.getElementById('btn-back-home').addEventListener('click', () => this.exitGame());
        document.getElementById('btn-retry').addEventListener('click', () => {
          document.getElementById('result-screen').classList.remove('visible');
          game.reset();
        });
        document.getElementById('btn-share').addEventListener('click', () => game.share());
        document.getElementById('btn-reset').addEventListener('click', () => game.reset());
        document.getElementById('btn-toggle').addEventListener('click', () => game.toggle());
        document.getElementById('btn-snap').addEventListener('click', () => game.snapshot());
        document.getElementById('btn-undo').addEventListener('click', () => game.undo());
        document.getElementById('btn-redo').addEventListener('click', () => game.redo());

        game.init();
      },

      applyLanguage(lang) {
        if (!i18n[lang]) return;
        this.lang = lang;
        localStorage.setItem('life-garden-lang', lang);
        document.documentElement.lang = lang;

        const dict = i18n[lang];
        document.title = dict.pageTitle;
        const metaDesc = document.querySelector('meta[name="description"]');
        if (metaDesc) metaDesc.setAttribute('content', dict.metaDesc);

        document.querySelectorAll('[data-i18n]').forEach(el => {
          const key = el.dataset.i18n;
          if (dict[key]) el.innerText = dict[key];
        });
        document.querySelectorAll('[data-i18n-html]').forEach(el => {
          const key = el.dataset.i18nHtml;
          if (dict[key]) el.innerHTML = dict[key];
        });

        document.querySelectorAll('.lang-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.lang === lang);
        });

        game.updateUI();
      },

      enterGame() {
        this.isGameMode = true;
        window.scrollTo(0, 0);
        document.body.classList.add('game-mode');
        document.getElementById('content-layer').classList.add('hidden');
        document.getElementById('game-interface').classList.remove('hidden');
        game.startMatch();
      },

      exitGame() {
        this.isGameMode = false;
        document.body.classList.remove('game-mode');
        document.getElementById('content-layer').classList.remove('hidden');
        document.getElementById('game-interface').classList.add('hidden');
        document.getElementById('result-screen').classList.remove('visible');
        game.toBackgroundMode();
      }
    };

    const game = {
      canvas: null,
      ctx: null,
      BASE_W: 30,
      BASE_H: 50,
      MIN_CELL: 14,

      LOGICAL_W: 30,
      LOGICAL_H: 50,
      grid: [],
      nextGrid: [],

      res: 0,
      offX: 0,
      offY: 0,
      state: 'BG', // BG, SETUP, RUNNING, RESULT
      gen: 0,
      score: 0,
      maxPop: 0,
      historySet: new Set(),
      undoStack: [],
      redoStack: [],
      maxHistory: 20,
      discovered: new Set(),
      lastShare: null,

      init() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });

        this.grid = new Array(this.LOGICAL_W).fill(0).map(() => new Array(this.LOGICAL_H).fill(0));
        this.nextGrid = new Array(this.LOGICAL_W).fill(0).map(() => new Array(this.LOGICAL_H).fill(0));

        window.addEventListener('resize', () => this.resize());
        this.resize();
        this.setupInput();
        this.loadDex();
        this.toBackgroundMode();
        this.loop();
      },

      resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        this.canvas.width = w;
        this.canvas.height = h;

        const resW = w / this.LOGICAL_W;
        const resH = h / this.LOGICAL_H;
        this.res = Math.min(resW, resH);

        const gridPixelW = this.LOGICAL_W * this.res;
        const gridPixelH = this.LOGICAL_H * this.res;
        this.offX = Math.floor((w - gridPixelW) / 2);
        this.offY = Math.floor((h - gridPixelH) / 2);
      },

      toBackgroundMode() {
        this.state = 'BG';
        this.clear();
        this.randomize(0.12);
      },

      startMatch() {
        this.state = 'SETUP';
        this.clear();
        const preview = document.getElementById('res-preview');
        if (preview) preview.style.display = 'none';
        const cx = Math.floor(this.LOGICAL_W / 2);
        const cy = Math.floor(this.LOGICAL_H / 2);
        this.setCell(cx, cy, 1);
        this.setCell(cx + 1, cy, 1);
        this.setCell(cx - 1, cy, 1);
        this.setCell(cx, cy - 1, 1);
        this.setCell(cx, cy + 1, 1);
        this.resetStats();
        this.redoStack = [];
        this.pushHistory(true);
        this.updateUI();
      },

      reset() {
        if (this.state === 'BG') return;
        const preview = document.getElementById('res-preview');
        if (preview) preview.style.display = 'none';
        this.pushHistory(true);
        this.state = 'SETUP';
        this.clear();
        this.resetStats();
        this.redoStack = [];
        this.updateUI();
      },

      toggle() {
        if (this.state === 'SETUP') this.state = 'RUNNING';
        else if (this.state === 'RUNNING') this.state = 'SETUP';
        this.updateUI();
      },

      clear() {
        for (let i = 0; i < this.LOGICAL_W; i++) this.grid[i].fill(0);
      },

      setCell(x, y, val) {
        if (x >= 0 && x < this.LOGICAL_W && y >= 0 && y < this.LOGICAL_H) {
          this.grid[x][y] = val;
          this.lastShare = null;
        }
      },

      serializeGrid() {
        let res = '';
        for (let y = 0; y < this.LOGICAL_H; y++) {
          for (let x = 0; x < this.LOGICAL_W; x++) {
            res += this.grid[x][y];
          }
        }
        return res;
      },

      restoreGrid(state) {
        if (!state || state.w !== this.LOGICAL_W || state.h !== this.LOGICAL_H) return false;
        let idx = 0;
        for (let y = 0; y < state.h; y++) {
          for (let x = 0; x < state.w; x++) {
            this.grid[x][y] = Number(state.data[idx++] || 0);
          }
        }
        this.historySet.clear();
        return true;
      },

      pushHistory(force = false) {
        const snapshot = { w: this.LOGICAL_W, h: this.LOGICAL_H, data: this.serializeGrid() };
        const last = this.undoStack[this.undoStack.length - 1];
        if (force || !last || last.data !== snapshot.data) {
          this.undoStack.push(snapshot);
          if (this.undoStack.length > this.maxHistory) this.undoStack.shift();
        }
      },

      undo() {
        if (this.undoStack.length <= 1) return;
        const current = { w: this.LOGICAL_W, h: this.LOGICAL_H, data: this.serializeGrid() };
        this.redoStack.push(current);
        const prev = this.undoStack[this.undoStack.length - 2];
        this.undoStack.pop();
        this.restoreGrid(prev);
        this.lastShare = null;
      },

      redo() {
        if (this.redoStack.length === 0) return;
        const next = this.redoStack.pop();
        this.undoStack.push(next);
        this.restoreGrid(next);
        this.lastShare = null;
      },

      loadDex() {
        try {
          const raw = localStorage.getItem('life-garden-dex');
          if (raw) {
            const arr = JSON.parse(raw);
            this.discovered = new Set(arr);
          }
        } catch (e) {
          this.discovered = new Set();
        }
        this.updateDexUI();
      },

      saveDex() {
        localStorage.setItem('life-garden-dex', JSON.stringify([...this.discovered]));
      },

      updateDexUI() {
        const total = PATTERNS.length;
        const found = this.discovered.size;
        const el = document.getElementById('dex-count');
        if (el) el.innerText = `${found}/${total}`;
      },

      randomize(p) {
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            this.grid[i][j] = Math.random() < p ? 1 : 0;
          }
        }
      },

      resetStats() {
        this.gen = 0;
        this.score = 0;
        this.maxPop = 0;
        this.historySet.clear();
        this.updateHUD();
        this.updateDexUI();
      },

      getHash() {
        let res = '';
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            res += this.grid[i][j];
          }
        }
        return res;
      },

      checkPatterns() {
        const foundNow = [];
        const grid = this.grid;
        const w = this.LOGICAL_W;
        const h = this.LOGICAL_H;

        for (const pattern of PATTERNS) {
          if (this.discovered.has(pattern.id)) continue;
          for (const variant of pattern.variants) {
            const maxX = Math.max(...variant.cells.map(c => c[0]));
            const maxY = Math.max(...variant.cells.map(c => c[1]));
            for (let x = 0; x <= w - (maxX + 1); x++) {
              for (let y = 0; y <= h - (maxY + 1); y++) {
                if (this.matchesPattern(grid, x, y, variant)) {
                  foundNow.push(pattern.id);
                  this.registerPattern(pattern);
                  x = w; y = h; // break loops
                  break;
                }
              }
            }
            if (this.discovered.has(pattern.id)) break;
          }
        }
        if (foundNow.length) this.updateDexUI();
      },

      matchesPattern(grid, ox, oy, variant) {
        const required = new Set(variant.cells.map(([x, y]) => `${x},${y}`));
        const maxX = Math.max(...variant.cells.map(c => c[0]));
        const maxY = Math.max(...variant.cells.map(c => c[1]));
        for (let x = 0; x <= maxX; x++) {
          for (let y = 0; y <= maxY; y++) {
            const alive = grid[ox + x][oy + y] === 1;
            const needAlive = required.has(`${x},${y}`);
            if (needAlive !== alive) return false;
          }
        }
        return true;
      },

      registerPattern(pattern) {
        this.discovered.add(pattern.id);
        this.saveDex();
        const name = pattern.name[app.lang] || pattern.name.ja;
        const msg = i18n[app.lang].newPattern(name);
        toast.show(msg);
        this.updateDexUI();
      },

      update() {
        if (this.state !== 'RUNNING' && this.state !== 'BG') return;

        if (this.state === 'RUNNING') {
          this.lastShare = null;
        }

        let active = 0;
        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            const s = this.grid[i][j];
            let sum = 0;
            for (let x = -1; x <= 1; x++) {
              for (let y = -1; y <= 1; y++) {
                if (x === 0 && y === 0) continue;
                const c = (i + x + this.LOGICAL_W) % this.LOGICAL_W;
                const r = (j + y + this.LOGICAL_H) % this.LOGICAL_H;
                sum += this.grid[c][r];
              }
            }

            if (s === 0 && sum === 3) this.nextGrid[i][j] = 1;
            else if (s === 1 && (sum < 2 || sum > 3)) this.nextGrid[i][j] = 0;
            else this.nextGrid[i][j] = s;

            if (this.nextGrid[i][j] === 1) active++;
          }
        }

        [this.grid, this.nextGrid] = [this.nextGrid, this.grid];

        if (this.state === 'RUNNING') {
          this.gen++;
          if (active > this.maxPop) this.maxPop = active;
          this.score = (this.gen * 10) + (this.maxPop * 5);
          this.updateHUD();

          if (active === 0) {
            this.gameOver('EXTINCTION');
            return;
          }

          const currentHash = this.getHash();
          if (this.historySet.has(currentHash)) {
            this.gameOver('LOOP');
            this.historySet.clear();
            return;
          }
          this.historySet.add(currentHash);
          if (this.historySet.size > 2000) this.historySet.clear();

          if (this.gen > 10000) {
            this.gameOver('ETERNAL');
            return;
          }

          if (this.gen % 5 === 0) {
            this.checkPatterns();
          }
        }
      },

      gameOver(reasonKey) {
        this.state = 'RESULT';
        const dict = i18n[app.lang];
        const reasonText = dict.reasons[reasonKey] || 'GAME OVER';
        document.getElementById('res-reason').innerText = reasonText;
        document.getElementById('res-score').innerText = this.score;
        document.getElementById('res-gen-val').innerText = this.gen;
        document.getElementById('res-pop-val').innerText = this.maxPop;
        document.getElementById('result-screen').classList.add('visible');
        this.prepareResultPreview();
      },

      async prepareResultPreview() {
        try {
          const img = await this.ensureShareImage();
          const el = document.getElementById('res-preview');
          if (el && img?.dataUrl) {
            el.src = img.dataUrl;
            el.style.display = 'block';
          }
        } catch (e) {
          console.log('Preview generation failed', e);
        }
      },

      draw() {
        this.ctx.fillStyle = '#0a0a0f';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.state !== 'BG') {
          this.ctx.fillStyle = '#0f0f16';
          this.ctx.fillRect(this.offX, this.offY, this.LOGICAL_W * this.res, this.LOGICAL_H * this.res);
          this.ctx.strokeStyle = '#2a2a35';
          this.ctx.strokeRect(this.offX, this.offY, this.LOGICAL_W * this.res, this.LOGICAL_H * this.res);
        }

        this.ctx.fillStyle = this.state === 'BG' ? '#333' : '#b249f8';
        this.ctx.shadowBlur = this.state === 'BG' ? 0 : 10;
        this.ctx.shadowColor = '#b249f8';

        for (let i = 0; i < this.LOGICAL_W; i++) {
          for (let j = 0; j < this.LOGICAL_H; j++) {
            if (this.grid[i][j] === 1) {
              const x = this.offX + i * this.res;
              const y = this.offY + j * this.res;
              this.ctx.beginPath();
              this.ctx.rect(x + 1, y + 1, this.res - 1.6, this.res - 1.6);
              this.ctx.fill();
            }
          }
        }
      },

      loop() {
        if (this.state === 'BG') {
          this.update();
        } else {
          this.update();
        }
        this.draw();
        requestAnimationFrame(() => this.loop());
      },

      setupInput() {
        let isDrag = false;
        let paintMode = 1;
        let lastPoint = null;
        let snapshotTaken = false;

        const getGridPos = (clientX, clientY) => {
          const gx = Math.floor((clientX - this.offX) / this.res);
          const gy = Math.floor((clientY - this.offY) / this.res);
          return { x: gx, y: gy };
        };

        const paintCell = (x, y, val) => {
          if (x >= 0 && x < this.LOGICAL_W && y >= 0 && y < this.LOGICAL_H) {
            this.grid[x][y] = val;
          }
        };

        const paintLine = (from, to, val) => {
          let x0 = from.x, y0 = from.y, x1 = to.x, y1 = to.y;
          const dx = Math.abs(x1 - x0);
          const dy = Math.abs(y1 - y0);
          const sx = x0 < x1 ? 1 : -1;
          const sy = y0 < y1 ? 1 : -1;
          let err = dx - dy;
          while (true) {
            paintCell(x0, y0, val);
            if (x0 === x1 && y0 === y1) break;
            const e2 = 2 * err;
            if (e2 > -dy) { err -= dy; x0 += sx; }
            if (e2 < dx) { err += dx; y0 += sy; }
          }
        };

        const startStroke = (cx, cy) => {
          // 編集はセットアップのみ許可。RUNNING/BGでは無効。
          if (this.state !== 'SETUP') return false;
          if (!snapshotTaken) {
            this.pushHistory();
            this.redoStack = [];
            snapshotTaken = true;
          }

          const p = getGridPos(cx, cy);
          if (p.x >= 0 && p.x < this.LOGICAL_W && p.y >= 0 && p.y < this.LOGICAL_H) {
            isDrag = true;
            paintMode = this.grid[p.x][p.y] === 1 ? 0 : 1;
            paintCell(p.x, p.y, paintMode);
            lastPoint = p;
            return true;
          }
          return false;
        };

        const moveStroke = (cx, cy) => {
          if (!isDrag) return;
          const p = getGridPos(cx, cy);
          if (p.x >= 0 && p.x < this.LOGICAL_W && p.y >= 0 && p.y < this.LOGICAL_H && lastPoint) {
            paintLine(lastPoint, p, paintMode);
            lastPoint = p;
          }
        };

        const endStroke = () => {
          isDrag = false;
          lastPoint = null;
          if (snapshotTaken) {
            this.checkPatterns();
          }
          snapshotTaken = false;
        };

        this.canvas.addEventListener('pointerdown', e => {
          e.preventDefault();
          const began = startStroke(e.clientX, e.clientY);
          if (began) this.canvas.setPointerCapture(e.pointerId);
        });
        this.canvas.addEventListener('pointermove', e => {
          if (!isDrag) return;
          e.preventDefault();
          moveStroke(e.clientX, e.clientY);
        });
        const release = e => {
          endStroke();
          if (e.pointerId !== undefined) this.canvas.releasePointerCapture(e.pointerId);
        };
        this.canvas.addEventListener('pointerup', release);
        this.canvas.addEventListener('pointercancel', release);

        window.addEventListener('keydown', e => {
          if (app.isGameMode && e.code === 'Space') {
            e.preventDefault();
            this.toggle();
          }
          if (app.isGameMode && (e.key === 'r' || e.key === 'R')) {
            e.preventDefault();
            this.reset();
          }
        });
      },

      snapshot() {
        this.ensureShareImage().then(img => {
          const a = document.createElement('a');
          a.download = `lifegarden-${this.score}.png`;
          a.href = img?.dataUrl || this.canvas.toDataURL('image/png');
          a.click();
        });
      },

      async ensureShareImage() {
        if (this.lastShare && this.lastShare.gen === this.gen && this.lastShare.score === this.score && this.lastShare.maxPop === this.maxPop) {
          return this.lastShare;
        }
        try {
          const created = await this.generateShareImage();
          this.lastShare = { ...created, gen: this.gen, score: this.score, maxPop: this.maxPop };
          return this.lastShare;
        } catch (e) {
          console.log('Share image generation failed', e);
          return null;
        }
      },

      async generateShareImage() {
        const w = 1080;
        const h = 1920;
        const c = document.createElement('canvas');
        c.width = w;
        c.height = h;
        const ctx = c.getContext('2d');

        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, '#0e0b1e');
        grad.addColorStop(1, '#1a0f2f');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);

        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        ctx.fillRect(70, 120, w - 140, h - 190);

        const scale = Math.min((w - 160) / this.canvas.width, (h * 0.5) / this.canvas.height);
        const imgW = this.canvas.width * scale;
        const imgH = this.canvas.height * scale;
        const imgX = (w - imgW) / 2;
        const imgY = 160;
        ctx.drawImage(this.canvas, imgX, imgY, imgW, imgH);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 64px Outfit, sans-serif';
        ctx.fillText('Life Garden', 90, imgY + imgH + 120);
        ctx.fillStyle = '#49f8f8';
        ctx.font = '28px Outfit, sans-serif';
        ctx.fillText('Eternal Simple Fun', 90, imgY + imgH + 160);

        ctx.fillStyle = '#fff';
        ctx.font = '52px Outfit, sans-serif';
        ctx.fillText(`Score: ${this.score}`, 90, imgY + imgH + 240);
        ctx.font = '34px Outfit, sans-serif';
        ctx.fillText(`${i18n[app.lang].resultGen}: ${this.gen}`, 90, imgY + imgH + 300);
        ctx.fillText(`${i18n[app.lang].resultPop}: ${this.maxPop}`, 90, imgY + imgH + 350);

        ctx.strokeStyle = '#b249f8';
        ctx.lineWidth = 6;
        ctx.strokeRect(80, 130, w - 160, h - 210);

        ctx.fillStyle = '#49f8f8';
        ctx.font = '28px Outfit, sans-serif';
        ctx.fillText('#LifeGarden', 90, imgY + imgH + 400);
        ctx.fillStyle = '#ccc';
        ctx.font = '24px Outfit, sans-serif';
        ctx.fillText('Grow it. Share it. Challenge me.', 90, imgY + imgH + 440);

        const dataUrl = c.toDataURL('image/png');
        const blob = await new Promise(resolve => c.toBlob(resolve, 'image/png', 0.95));
        return { blob, dataUrl };
      },

      async share() {
        const dict = i18n[app.lang];
        const text = dict.shareText(this.gen, this.score, this.maxPop);
        const url = "https://ikuto-yamaguchi.github.io/";

        const shareImg = await this.ensureShareImage();

        try {
          if (shareImg?.blob) {
            const file = new File([shareImg.blob], "score.png", { type: "image/png" });
            if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
              await navigator.share({
                title: dict.shareTitle,
                text,
                url,
                files: [file]
              });
              return;
            }
          }
        } catch (e) {
          console.log("Web Share API failed, falling back", e);
        }

        const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}&hashtags=LifeGarden`;
        window.open(tweetUrl, '_blank');
      },

      updateHUD() {
        document.getElementById('disp-score').innerText = this.score;
        document.getElementById('disp-gen').innerText = this.gen;
      },

      updateUI() {
        const dict = i18n[app.lang];
        const btn = document.getElementById('btn-toggle');
        const label = this.state === 'RUNNING' ? dict.btnPause : dict.btnPlay;
        btn.innerText = label.toUpperCase();
        btn.setAttribute('aria-pressed', this.state === 'RUNNING');
        btn.title = label;
        btn.classList.toggle('active', this.state !== 'RUNNING');

        document.getElementById('btn-reset').title = dict.btnReset;
        document.getElementById('btn-snap').title = dict.btnSnap;
        document.getElementById('btn-exit-game').title = dict.btnQuit;
        document.getElementById('btn-exit-game').setAttribute('aria-label', dict.btnQuit);
        document.getElementById('btn-undo').title = dict.btnUndo;
        document.getElementById('btn-redo').title = dict.btnRedo;
        document.getElementById('hud-score-label').innerText = dict.hudScore;
        document.getElementById('hud-gen-label').innerText = dict.hudGen;
        document.getElementById('dex-pill').querySelector('.score-label').innerText = dict.dexLabel;
        document.getElementById('btn-share').innerText = dict.btnShare;
        document.getElementById('btn-retry').innerText = dict.btnRetry;
        document.getElementById('btn-back-home').innerText = dict.backHome;
        document.querySelector('[data-i18n="resultGen"]').innerText = dict.resultGen;
        document.querySelector('[data-i18n="resultPop"]').innerText = dict.resultPop;
      }
    };

    window.addEventListener('DOMContentLoaded', () => {
      app.init();
    });
  </script>
</body>
</html>
